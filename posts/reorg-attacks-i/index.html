<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Reorg Attacks I | Sidereus Hu</title>
<meta name="keywords" content="">
<meta name="description" content="
Core Objective


Core Purpose: The goal of the attack (by Byzantine validators) is not to break the system (such as double-spending), but rather to manipulate block publication and voting so that their &ldquo;privately held&rdquo; block (b₁) defeats an honest block (b₂), thereby becoming the main chain.


Ultimate Gain: By making the honest b₂ block become &ldquo;orphaned,&rdquo; Byzantine validators can &ldquo;steal&rdquo; the block rewards that should have belonged to the b₂ proposer, thus obtaining &ldquo;higher rewards.&rdquo;">
<meta name="author" content="Sidereus Hu">
<link rel="canonical" href="https://sidereushu.github.io/posts/reorg-attacks-i/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css" integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sidereushu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sidereushu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sidereushu.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sidereushu.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://sidereushu.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://sidereushu.github.io/posts/reorg-attacks-i/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)'], ['$', '$']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
 


<meta property="og:url" content="https://sidereushu.github.io/posts/reorg-attacks-i/">
  <meta property="og:site_name" content="Sidereus Hu">
  <meta property="og:title" content="Reorg Attacks I">
  <meta property="og:description" content="
Core Objective Core Purpose: The goal of the attack (by Byzantine validators) is not to break the system (such as double-spending), but rather to manipulate block publication and voting so that their “privately held” block (b₁) defeats an honest block (b₂), thereby becoming the main chain.
Ultimate Gain: By making the honest b₂ block become “orphaned,” Byzantine validators can “steal” the block rewards that should have belonged to the b₂ proposer, thus obtaining “higher rewards.”">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-23T16:57:25+08:00">
    <meta property="article:modified_time" content="2025-10-23T16:57:25+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Reorg Attacks I">
<meta name="twitter:description" content="
Core Objective


Core Purpose: The goal of the attack (by Byzantine validators) is not to break the system (such as double-spending), but rather to manipulate block publication and voting so that their &ldquo;privately held&rdquo; block (b₁) defeats an honest block (b₂), thereby becoming the main chain.


Ultimate Gain: By making the honest b₂ block become &ldquo;orphaned,&rdquo; Byzantine validators can &ldquo;steal&rdquo; the block rewards that should have belonged to the b₂ proposer, thus obtaining &ldquo;higher rewards.&rdquo;">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sidereushu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Reorg Attacks I",
      "item": "https://sidereushu.github.io/posts/reorg-attacks-i/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Reorg Attacks I",
  "name": "Reorg Attacks I",
  "description": "\nCore Objective Core Purpose: The goal of the attack (by Byzantine validators) is not to break the system (such as double-spending), but rather to manipulate block publication and voting so that their \u0026ldquo;privately held\u0026rdquo; block (b₁) defeats an honest block (b₂), thereby becoming the main chain.\nUltimate Gain: By making the honest b₂ block become \u0026ldquo;orphaned,\u0026rdquo; Byzantine validators can \u0026ldquo;steal\u0026rdquo; the block rewards that should have belonged to the b₂ proposer, thus obtaining \u0026ldquo;higher rewards.\u0026rdquo;\n",
  "keywords": [
    
  ],
  "articleBody": "\nCore Objective Core Purpose: The goal of the attack (by Byzantine validators) is not to break the system (such as double-spending), but rather to manipulate block publication and voting so that their “privately held” block (b₁) defeats an honest block (b₂), thereby becoming the main chain.\nUltimate Gain: By making the honest b₂ block become “orphaned,” Byzantine validators can “steal” the block rewards that should have belonged to the b₂ proposer, thus obtaining “higher rewards.”\nLegend normal block (white square): A normal, consensus-confirmed block. withheld block (dashed red square): A withheld block. This is the key to the attack—the block has been created and privately voted on, but not broadcast to the network. delayed block (solid red square): A delayed release block. This is the state when a “withheld block” is finally released to the network. orphaned block (square with diagonal lines): Orphaned block. A valid block that was not selected for the main chain. vote for a block (circle): A vote for a block. delay a block (arrow with circle): This icon is somewhat ambiguous, but in context, it likely represents the combined action of Byzantine validators privately voting and deciding to withhold (delay) this block. Attack Flow Breakdown Starting Point (Time = T0): b₀ is a normal block (white square). This is the commonly recognized starting main chain.\nByzantine “Conspiracy” (Time = T1): After b₀, b₁ appears. Note that b₁ is drawn as a withheld block (dashed red square).\nThis means vᵢ proposed b₁, and all Byzantine validators privately voted for it (represented by the red circles vote for a block and the delay a block arrows in the diagram), but they withheld b₁ and did not broadcast it to other honest nodes. Honest Validators’ “Open Play” (Time = T2): In the next slot:\nAn honest validator (who is unaware of b₁’s existence) proposes block b₂ based on b₀. b₂ is broadcast normally. At this moment, for honest nodes, the main chain is: b₀ → b₂ Attack Execution and Fork Competition (Time = T2 instant): Just as b₂ is proposed, Byzantine validators immediately release their privately held b₁ to the network: b₁’s status changes from withheld block (dashed) to delayed block (solid red square).\nResult: At this point, a fork appears in the network: Honest chain: b₀ → b₂ Byzantine chain: b₀ → b₁ Consensus Ruling (Time = T3):\nHonest chain b₀ → b₂ weight = b₀’s weight + b₂’s weight (possibly only the b₂ proposer and a few nodes that just received it voted). Byzantine chain b₀ → b₁ weight = b₀’s weight + b₁’s weight (b₁ proposer + all Byzantine validators’ premeditated votes). Due to the Byzantine validators’ “premeditated” votes, once the b₁ chain is released, its weight immediately exceeds the b₂ chain. Sandwich Reorg Attack The “Sandwich Reorg Attack” is a sophisticated attack against Ethereum’s consensus HLMD-GHOST fork choice rule. In Ethereum’s consensus (particularly Casper FFG + LMD-GHOST), LMD-GHOST (Latest Message Driven GHOST) is a voting weight-based fork choice rule:\nEach validator votes (attestation) for what they consider the “heaviest chain.” Each fork’s “weight” = the number of validator votes received (weighted). The chain head is selected as the branch with the highest cumulative weight. “Sandwich” Attack Concept The attacker inserts their own hidden chain between two honest blocks, causing the network’s weight judgment to reverse.\nIn Ethereum, each slot has a proposer. To reduce empty blocks and accelerate finality convergence, the system gives the current slot’s proposer a temporary weight boost, known as “proposer boosting.”\nThis boost is typically about 70% of the total weight. Meaning: The proposer’s own block’s branch receives temporary weighting to encourage the chain to advance toward the new block. This mechanism itself is beneficial—but attackers can abuse it, leading to reorganization.\nAttack Timeline Time Action Explanation t b₀ This is the common ancestor (starting point) of the chain. t+1 Attacker vᵢ proposes b₁ (red block) But the attacker temporarily does not broadcast b₁ (dashed border). t+2 Honest validator proposes b₂ (gray block) Since the attacker hasn’t published b₁, everyone believes b₂ is the legitimate newest chain inheriting from b₀. Thus, most validators vote for b₂, making the b₂ chain have higher weight at this time. t+3 Attacker vᵢ publishes b₁ and has accomplice vⱼ propose b₃ with b₁ as parent The key here: b₃ uses the proposer boosting mechanism, gaining a 70% weight bonus for the current slot. Since this weight exceeds honest validators’ voting power (less than 70%), the branch b₀→b₁→b₃ is considered the “heavier chain”. Thus, the original b₂ chain is reorganized (reorg’d) out. Balancing Attack Attack Structure b₀ (white square) is the common ancestor/base chain head, existing at time t and accepted by honest nodes as the current head. In two consecutive slots t+1 and t+2, both proposers are Byzantine, vᵢ (at t+1) and vⱼ (at t+2) respectively. vᵢ generates block b₁ (red dashed box—withheld) at t+1, but does not immediately broadcast it. vⱼ at t+2 both publishes their own proposed b₂ and simultaneously releases the previously hidden b₁. Note that both b₁ and b₂ have b₀ as parent (binary fork, forming two parallel chains). Vote Splitting Strategy The attacker divides honest validators into two groups V₁ and V₂, with both groups equal in size (or weight).\nThe attacker prepares two sets of attestations:\na₁: Supporting the chain with b₁ as head (internally collected or disguised as “evidence that b₁ is heavier”), releasing a₁ only to V₁. a₂: Supporting the chain with b₂ as head, releasing a₂ only to V₂. Result: V₁ members, after seeing a₁, believe b₁ is heavier and only vote for b₁; V₂ members, after seeing a₂, only vote for b₂. Thus, at the end of t+2, the accumulated attestation weight of both chains is equal (or nearly equal), so neither can form more than 2/3 support to finalize (under the classic 2/3 finality setting), nor can either be clearly selected as the long-term main chain by HLMD-GHOST → resulting in the system’s long-term inability to achieve finality (liveness is compromised), causing system availability to collapse.\nWhy This Blocks Finality (Intuitive Reason) In voting weight-based fork-choice (HLMD-GHOST), finality depends on continuously appearing consecutive checkpoints that can obtain \u003e2/3 weight support. Through careful “information distribution” (selective release of attestations), the attacker partitions the information view of honest validators into two groups, causing each fork to receive only about half of the honest votes. Since no branch can gain enough majority votes, no checkpoint can accumulate beyond the finality threshold (e.g., \u003e2/3), so the chain cannot finalize—this is liveness being blocked (not safety being broken, but progress/availability being blocked). Attack Prerequisites To successfully and continuously launch a balancing attack, the attacker needs at least some or all of the following capabilities/conditions:\nControl of two consecutive slot proposers (both consecutive proposers are Byzantine)\nThis is the core assumption in the diagram: the attacker has block production rights in consecutive proposer slots, enabling them to create and delay/parallel publish forked blocks b₁, b₂. Selective information propagation (message partition/targeted gossip) capability:\nThe attacker must be able to control which honest validators see which attestations (or blocks) first, i.e., can send messages only to V₁ or V₂. This can be accomplished through network layer partitioning (actual network division or delay) or through selective forwarding of certain messages. Note: The attacker does not need to control honest validators’ signing authority; only needs to control information visibility (who-sees-what). Sufficient stake/weight distribution conditions (weakened version):\nTo make both sides’ weights exactly balanced, the attacker doesn’t need to hold a large proportion of stake, but needs to be able to divide honest validators into two groups with roughly equal weight (this can be achieved through social engineering, network delays, directed information propagation, etc.). If honest validator weights are very uneven or difficult to divide equally, the attack cost will be higher. Sustained repeated launch capability:\nTo keep the chain continuously unable to finalize, the attacker must repeat the above operations over multiple epoch/slot cycles (especially when checkpoint spans are large). If it’s only a one-time operation, the network may still recover finality subsequently. Summary: The attack heavily relies on network layer manipulation and proposer control. In environments where the network is partially controllable or the attacker can control several proposers, this is a realistic threat.\nSuccess Probability / Cost (Qualitative Discussion) If proposer election is random and public, and the attacker cannot long-term control consecutive proposers, the attack success probability is low.\nIf the attacker can long-term control several proposers (or occupy a high proportion of proposer positions through Byzantine nodes), or can temporarily partition the network/selectively forward, the success probability significantly increases.\nCosts include: acquiring consecutive proposers (stake cost or election probability), constructing and maintaining network control costs for targeted gossip, bearing possible slashing/penalty risks (if detection and penalty mechanisms exist).\n",
  "wordCount" : "1459",
  "inLanguage": "zh",
  "datePublished": "2025-10-23T16:57:25+08:00",
  "dateModified": "2025-10-23T16:57:25+08:00",
  "author":{
    "@type": "Person",
    "name": "Sidereus Hu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sidereushu.github.io/posts/reorg-attacks-i/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sidereus Hu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sidereushu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sidereushu.github.io/" accesskey="h" title="Sidereus Hu (Alt + H)">Sidereus Hu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sidereushu.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://sidereushu.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Reorg Attacks I
    </h1>
    <div class="post-meta"><span title='2025-10-23 16:57:25 +0800 CST'>2025-10-23</span>&nbsp;·&nbsp;Sidereus Hu

</div>
  </header> 
  <div class="post-content"><br>
<h2 id="core-objective">Core Objective<a hidden class="anchor" aria-hidden="true" href="#core-objective">#</a></h2>
<ol>
<li>
<p><strong>Core Purpose</strong>: The goal of the attack (by Byzantine validators) is <strong>not</strong> to break the system (such as double-spending), but rather to manipulate block publication and voting so that their &ldquo;privately held&rdquo; block (b₁) defeats an honest block (b₂), thereby becoming the main chain.</p>
</li>
<li>
<p><strong>Ultimate Gain</strong>: By making the honest b₂ block become &ldquo;orphaned,&rdquo; Byzantine validators can &ldquo;steal&rdquo; the block rewards that should have belonged to the b₂ proposer, thus obtaining &ldquo;higher rewards.&rdquo;</p>
</li>
</ol>
<p><img loading="lazy" src="/images/ReorgAttack.png"></p>
<h2 id="legend">Legend<a hidden class="anchor" aria-hidden="true" href="#legend">#</a></h2>
<ul>
<li><code>normal block</code> (white square): A normal, consensus-confirmed block.</li>
<li><code>withheld block</code> (dashed red square): <strong>A withheld block</strong>. This is the key to the attack—the block has been created and privately voted on, but not broadcast to the network.</li>
<li><code>delayed block</code> (solid red square): <strong>A delayed release block</strong>. This is the state when a &ldquo;withheld block&rdquo; is finally released to the network.</li>
<li><code>orphaned block</code> (square with diagonal lines): <strong>Orphaned block</strong>. A valid block that was not selected for the main chain.</li>
<li><code>vote for a block</code> (circle): A vote for a block.</li>
<li><code>delay a block</code> (arrow with circle): This icon is somewhat ambiguous, but in context, it likely represents the combined action of Byzantine validators <em>privately voting</em> and <em>deciding to withhold</em> (delay) this block.</li>
</ul>
<h2 id="attack-flow-breakdown">Attack Flow Breakdown<a hidden class="anchor" aria-hidden="true" href="#attack-flow-breakdown">#</a></h2>
<ol>
<li>
<p><strong>Starting Point (Time = T0)</strong>: b₀ is a <code>normal block</code> (white square). This is the commonly recognized starting main chain.</p>
</li>
<li>
<p><strong>Byzantine &ldquo;Conspiracy&rdquo; (Time = T1)</strong>: After b₀, b₁ appears. Note that b₁ is drawn as a withheld block (dashed red square).</p>
<ul>
<li>This means vᵢ proposed b₁, and <em>all</em> Byzantine validators <em>privately</em> voted for it (represented by the red circles <code>vote for a block</code> and the <code>delay a block</code> arrows in the diagram), but they <strong>withheld</strong> b₁ and did not broadcast it to other honest nodes.</li>
</ul>
</li>
<li>
<p><strong>Honest Validators&rsquo; &ldquo;Open Play&rdquo; (Time = T2)</strong>: In the next slot:</p>
<ul>
<li>An <em>honest</em> validator (who is <em>unaware</em> of b₁&rsquo;s existence) proposes block b₂ based on b₀.</li>
<li>b₂ is broadcast normally. At this moment, for honest nodes, the main chain is: b₀ → b₂</li>
</ul>
</li>
<li>
<p><strong>Attack Execution and Fork Competition (Time = T2 instant)</strong>: Just as b₂ is proposed, Byzantine validators <em>immediately</em> release their privately held b₁ to the network: b₁&rsquo;s status changes from <code>withheld block</code> (dashed) to <strong><code>delayed block</code></strong> (solid red square).</p>
<ul>
<li><strong>Result</strong>: At this point, a <strong>fork</strong> appears in the network:
<ul>
<li><strong>Honest chain</strong>: b₀ → b₂</li>
<li><strong>Byzantine chain</strong>: b₀ → b₁</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Consensus Ruling (Time = T3)</strong>:</p>
<ul>
<li>Honest chain b₀ → b₂ weight = b₀&rsquo;s weight + b₂&rsquo;s weight (possibly only the b₂ proposer and a few nodes that just received it voted).</li>
<li>Byzantine chain b₀ → b₁ weight = b₀&rsquo;s weight + b₁&rsquo;s weight (b₁ proposer + <em>all</em> Byzantine validators&rsquo; premeditated votes).</li>
<li>Due to the Byzantine validators&rsquo; &ldquo;premeditated&rdquo; votes, once the b₁ chain is released, its weight immediately exceeds the b₂ chain.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="sandwich-reorg-attack">Sandwich Reorg Attack<a hidden class="anchor" aria-hidden="true" href="#sandwich-reorg-attack">#</a></h2>
<p>The <strong>&ldquo;Sandwich Reorg Attack&rdquo;</strong> is a sophisticated attack against Ethereum&rsquo;s consensus <strong>HLMD-GHOST fork choice rule</strong>. In Ethereum&rsquo;s consensus (particularly Casper FFG + LMD-GHOST), <strong>LMD-GHOST (Latest Message Driven GHOST)</strong> is a voting weight-based fork choice rule:</p>
<ul>
<li>Each validator votes (attestation) for what they consider the &ldquo;heaviest chain.&rdquo;</li>
<li>Each fork&rsquo;s &ldquo;weight&rdquo; = the number of validator votes received (weighted).</li>
<li>The chain head is selected as the branch with <strong>the highest cumulative weight</strong>.</li>
</ul>
<p><img loading="lazy" src="/images/Reorg_Sandwich.png"></p>
<h3 id="sandwich-attack-concept">&ldquo;Sandwich&rdquo; Attack Concept<a hidden class="anchor" aria-hidden="true" href="#sandwich-attack-concept">#</a></h3>
<blockquote>
<p>The attacker inserts their own hidden chain <strong>between two honest blocks</strong>, causing the network&rsquo;s weight judgment to reverse.</p></blockquote>
<p>In Ethereum, each slot has a proposer. To <strong>reduce empty blocks and accelerate finality convergence</strong>, the system gives the current slot&rsquo;s proposer a <strong>temporary weight boost</strong>, known as &ldquo;proposer boosting.&rdquo;</p>
<ul>
<li>This boost is typically about <strong>70% of the total weight</strong>.</li>
<li>Meaning: The proposer&rsquo;s own block&rsquo;s branch receives temporary weighting to encourage the chain to advance toward the new block.</li>
</ul>
<p>This mechanism itself is beneficial—but attackers can <strong>abuse it</strong>, leading to reorganization.</p>
<h3 id="attack-timeline">Attack Timeline<a hidden class="anchor" aria-hidden="true" href="#attack-timeline">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Time</th>
          <th>Action</th>
          <th>Explanation</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>t</strong></td>
          <td>b₀</td>
          <td>This is the common ancestor (starting point) of the chain.</td>
      </tr>
      <tr>
          <td><strong>t+1</strong></td>
          <td>Attacker vᵢ proposes b₁ (red block)</td>
          <td>But the attacker <strong>temporarily does not broadcast</strong> b₁ (dashed border).</td>
      </tr>
      <tr>
          <td><strong>t+2</strong></td>
          <td>Honest validator proposes b₂ (gray block)</td>
          <td>Since the attacker hasn&rsquo;t published b₁, everyone believes b₂ is the legitimate newest chain inheriting from b₀. Thus, most validators vote for b₂, making the b₂ chain <strong>have higher weight</strong> at this time.</td>
      </tr>
      <tr>
          <td><strong>t+3</strong></td>
          <td>Attacker vᵢ publishes b₁ and has accomplice vⱼ propose b₃ with b₁ as parent</td>
          <td>The key here: b₃ uses the <strong>proposer boosting</strong> mechanism, gaining a 70% weight bonus for the current slot. Since this weight exceeds honest validators&rsquo; voting power (less than 70%), the branch b₀→b₁→b₃ <strong>is considered the &ldquo;heavier chain&rdquo;</strong>. Thus, the original b₂ chain is reorganized (reorg&rsquo;d) out.</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="balancing-attack">Balancing Attack<a hidden class="anchor" aria-hidden="true" href="#balancing-attack">#</a></h2>
<h3 id="attack-structure">Attack Structure<a hidden class="anchor" aria-hidden="true" href="#attack-structure">#</a></h3>
<ul>
<li>b₀ (white square) is the common ancestor/base chain head, existing at time t and accepted by honest nodes as the current head.</li>
<li>In two consecutive slots t+1 and t+2, <strong>both proposers are Byzantine</strong>, vᵢ (at t+1) and vⱼ (at t+2) respectively.</li>
<li>vᵢ generates block b₁ (red dashed box—withheld) at t+1, but <strong>does not immediately broadcast</strong> it.</li>
<li>vⱼ at t+2 both publishes their own proposed b₂ and <strong>simultaneously releases the previously hidden b₁</strong>. Note that both b₁ and b₂ <strong>have b₀ as parent</strong> (binary fork, forming two parallel chains).</li>
</ul>
<p><img loading="lazy" src="/images/Reorg_Balancing.png"></p>
<h3 id="vote-splitting-strategy">Vote Splitting Strategy<a hidden class="anchor" aria-hidden="true" href="#vote-splitting-strategy">#</a></h3>
<ul>
<li>
<p>The attacker divides honest validators into two groups V₁ and V₂, with both groups <strong>equal in size (or weight)</strong>.</p>
</li>
<li>
<p>The attacker prepares two sets of attestations:</p>
<ul>
<li>a₁: Supporting the chain with b₁ as head (internally collected or disguised as &ldquo;evidence that b₁ is heavier&rdquo;), releasing a₁ only to V₁.</li>
<li>a₂: Supporting the chain with b₂ as head, releasing a₂ only to V₂.</li>
</ul>
</li>
<li>
<p><strong>Result</strong>: V₁ members, after seeing a₁, believe b₁ is heavier and only vote for b₁; V₂ members, after seeing a₂, only vote for b₂. Thus, at the end of t+2, the accumulated attestation weight of both chains is <strong>equal</strong> (or nearly equal), so neither can form more than 2/3 support to finalize (under the classic 2/3 finality setting), nor can either be clearly selected as the long-term main chain by HLMD-GHOST → resulting in the system&rsquo;s long-term inability to achieve finality (liveness is compromised), causing system availability to collapse.</p>
</li>
</ul>
<h3 id="why-this-blocks-finality-intuitive-reason">Why This Blocks Finality (Intuitive Reason)<a hidden class="anchor" aria-hidden="true" href="#why-this-blocks-finality-intuitive-reason">#</a></h3>
<ul>
<li>In voting weight-based fork-choice (HLMD-GHOST), finality depends on <strong>continuously appearing consecutive checkpoints that can obtain &gt;2/3 weight support</strong>.</li>
<li>Through careful &ldquo;information distribution&rdquo; (selective release of attestations), the attacker <strong>partitions the information view</strong> of honest validators into two groups, causing each fork to receive only about half of the honest votes.</li>
<li>Since no branch can gain enough majority votes, no checkpoint can accumulate beyond the <em>finality threshold</em> (e.g., &gt;2/3), so the chain cannot finalize—this is liveness being blocked (not safety being broken, but progress/availability being blocked).</li>
</ul>
<h3 id="attack-prerequisites">Attack Prerequisites<a hidden class="anchor" aria-hidden="true" href="#attack-prerequisites">#</a></h3>
<p>To successfully and continuously launch a balancing attack, the attacker needs at least some or all of the following capabilities/conditions:</p>
<ol>
<li>
<p><strong>Control of two consecutive slot proposers (both consecutive proposers are Byzantine)</strong></p>
<ul>
<li>This is the core assumption in the diagram: the attacker has block production rights in consecutive proposer slots, enabling them to create and delay/parallel publish forked blocks b₁, b₂.</li>
</ul>
</li>
<li>
<p><strong>Selective information propagation (message partition/targeted gossip) capability</strong>:</p>
<ul>
<li>The attacker must be able to control which honest validators see which attestations (or blocks) first, i.e., can send messages only to V₁ or V₂. This can be accomplished through <strong>network layer partitioning</strong> (actual network division or delay) or through selective forwarding of certain messages.</li>
<li>Note: The attacker does not need to control honest validators&rsquo; signing authority; only needs to control information visibility (who-sees-what).</li>
</ul>
</li>
<li>
<p><strong>Sufficient stake/weight distribution conditions (weakened version)</strong>:</p>
<ul>
<li>To make both sides&rsquo; weights exactly balanced, the attacker doesn&rsquo;t need to hold a large proportion of stake, but needs to be able to divide honest validators into two groups with roughly equal weight (this can be achieved through social engineering, network delays, directed information propagation, etc.). If honest validator weights are very uneven or difficult to divide equally, the attack cost will be higher.</li>
</ul>
</li>
<li>
<p><strong>Sustained repeated launch capability</strong>:</p>
<ul>
<li>To keep the chain continuously unable to finalize, the attacker must repeat the above operations over multiple epoch/slot cycles (especially when checkpoint spans are large). If it&rsquo;s only a one-time operation, the network may still recover finality subsequently.</li>
</ul>
</li>
</ol>
<p><strong>Summary</strong>: The attack heavily relies on network layer manipulation and proposer control. In environments where the network is partially controllable or the attacker can control several proposers, this is a realistic threat.</p>
<hr>
<h2 id="success-probability--cost-qualitative-discussion">Success Probability / Cost (Qualitative Discussion)<a hidden class="anchor" aria-hidden="true" href="#success-probability--cost-qualitative-discussion">#</a></h2>
<ul>
<li>
<p>If proposer election is random and public, and the attacker cannot long-term control consecutive proposers, the attack success probability is low.</p>
</li>
<li>
<p>If the attacker can long-term control several proposers (or occupy a high proportion of proposer positions through Byzantine nodes), or can temporarily partition the network/selectively forward, the success probability significantly increases.</p>
</li>
<li>
<p>Costs include: acquiring consecutive proposers (stake cost or election probability), constructing and maintaining network control costs for targeted gossip, bearing possible slashing/penalty risks (if detection and penalty mechanisms exist).</p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://sidereushu.github.io/">Sidereus Hu</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
