<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Poseidon Hash Algebraic Attack Analysis (Designer&#39;s Perspective) | Sidereus Hu</title>
<meta name="keywords" content="">
<meta name="description" content="
In recent years, &ldquo;ZK-friendly&rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.">
<meta name="author" content="Sidereus Hu">
<link rel="canonical" href="https://sidereushu.github.io/posts/poseidon-hash-algebraic-attack-analysis-designers-perspective/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css" integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sidereushu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sidereushu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sidereushu.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sidereushu.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://sidereushu.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://sidereushu.github.io/posts/poseidon-hash-algebraic-attack-analysis-designers-perspective/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)'], ['$', '$']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
 


<meta property="og:url" content="https://sidereushu.github.io/posts/poseidon-hash-algebraic-attack-analysis-designers-perspective/">
  <meta property="og:site_name" content="Sidereus Hu">
  <meta property="og:title" content="Poseidon Hash Algebraic Attack Analysis (Designer&#39;s Perspective)">
  <meta property="og:description" content="
In recent years, “ZK-friendly” hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-17T16:57:25+08:00">
    <meta property="article:modified_time" content="2025-08-17T16:57:25+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Poseidon Hash Algebraic Attack Analysis (Designer&#39;s Perspective)">
<meta name="twitter:description" content="
In recent years, &ldquo;ZK-friendly&rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sidereushu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Poseidon Hash Algebraic Attack Analysis (Designer's Perspective)",
      "item": "https://sidereushu.github.io/posts/poseidon-hash-algebraic-attack-analysis-designers-perspective/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Poseidon Hash Algebraic Attack Analysis (Designer's Perspective)",
  "name": "Poseidon Hash Algebraic Attack Analysis (Designer\u0027s Perspective)",
  "description": "\nIn recent years, \u0026ldquo;ZK-friendly\u0026rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.\n",
  "keywords": [
    
  ],
  "articleBody": "\nIn recent years, “ZK-friendly” hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.\nThis article approaches from a designer’s perspective, based on a recent paper [GKR25], presents some factual conclusions from that work, and provides supplementary analysis for certain conclusions.\nRelated Work Core Method Effectiveness Analysis for Poseidon [FP20] Closed-form degree expressions Helpful for modeling Gröbner basis attacks [BBLP22] Skipping (multiple) full rounds Reduced actual nonlinear depth [ABM24] Round-level Gröbner basis modeling Shows underestimated vulnerabilities at κ = 1024 [BBL+24] FreeLunch Gröbner basis attack Ineffective due to low S-box degree [KLR24] “Six Worlds” analysis framework Not yet applied to Poseidon, has potential research value [GKR25] Forward Gröbner basis attack utilizing subspace trajectories Original analysis shows overestimation or underestimation of required security rounds [BBB+25] Iterated Resultants Reducible to simple univariate cases [GKR25] is the latest work proposed by the Poseidon designers. This work provides the minimum partial rounds required for the Poseidon2 hash function to achieve 128-bit security in Sponge mode implementation, as shown in the figure below. The black line in the figure represents the parameter settings recommended by the Poseidon2 designers (where the dashed line indicates security redundancy of $+7.5\\% \\cdot r_{P}$), while other colored lines represent the authors’ test data for current mainstream attacks.\nFrom the black line in the figure, we can see that the Poseidon authors recommend partial rounds $r_{P}$ values in the 52-53 range. This data is calculated from the following theoretical lower bound formula:\n$$ r_F = 6 ; (r_f = 3, ; r_f' = 3) , , $$$$ r_P = \\left\\lceil \\max \\left\\{ \\underbrace{1 + \\frac{\\min\\{\\kappa, \\log_2(p)\\}}{\\log_2(\\alpha)} + \\log_{\\alpha}(t) - r_F}_{\\text{Term1}}, \\; r_{GB} \\right\\} \\right\\rceil , $$$$ r_{GB} = \\max \\left\\{ \\frac{\\min\\{\\log_2(p), \\kappa\\}}{\\log_2(\\alpha)} - r_F, \\; t - 1 + \\log_{\\alpha}(2) \\cdot \\min \\left\\{ \\frac{\\kappa}{t+1}, \\frac{\\log_2(p)}{2} \\right\\} - r_F' \\right\\} .$$ Verification of Poseidon Authors’ results: We first select a parameter set to verify whether we can confirm the authors’ results shown in the figure:\nParameters:\n$p \\approx 2^{256}$ (therefore $\\log_2(p) = 256$) $\\alpha = 5$ $t = 8$ $\\kappa = 128$ $r_F = 6$ (we first ignore the security margin) Calculate intermediate values:\n$\\log_2(\\alpha) = \\log_2(5) \\approx 2.322$\n$\\log_\\alpha(t) = \\log_5(8) = \\frac{\\log_2(8)}{\\log_2(5)} = \\frac{3}{2.322} \\approx 1.292$\nStep 1: Compute Term 1 (defense against interpolation attacks) $$ \\mathrm{Term} 1 = 1 + \\frac{\\min\\{128, 256\\}}{2.322} + 1.292 - 6 $$ $$ = 1 + \\frac{128}{2.322} + 1.292 - 6 $$ $$ \\approx 1 + 55.125 + 1.292 - 6 $$ $$ \\approx 51.417 $$ Step 2: Compute Term 2 ($r_{GB}$) The formula for $r_{GB}$ also contains a $\\max$ operation. We’ll calculate its main components separately (temporarily ignoring the unknown $r'_{GB}$ in the formula):\nFirst part of $r_{GB}$: $$ \\frac{\\min{\\log_2(p), \\kappa}}{\\log_2(\\alpha)} - r_F = \\frac{\\min\\{256, 128\\}}{2.322} - 6 \\approx 55.125 - 6 = 49.125 $$ Second part of $r_{GB}$:\n$\\log_{\\alpha}(2) = \\frac{\\log_2(2)}{\\log_2(5)} = \\frac{1}{2.322} \\approx 0.431$\n$\\min\\left\\{\\frac{\\kappa}{t+1}, \\frac{\\log_2(p)}{2}\\right\\} = \\min\\left\\{\\frac{128}{8+1}, \\frac{256}{2}\\right\\} = \\min\\{14.22, 128\\} = 14.22$\n$t - 1 + \\log_{\\alpha}(2) \\cdot (14.22) - r_F = 8 - 1 + 0.431 \\cdot 14.22 - 6 \\approx 7 + 6.13 - 6 = 7.13$\nTherefore, $r_{GB} = \\max{\\{49.125, 7.13\\}}$. We can see that $r_{GB}$ is at least $49.125$.\nStep 3: Final $r_P$ Calculation $$ r_P = \\max{\\{\\text{Term } 1\\},~~ r_{GB}} = \\max{\\{51.417, r_{GB}\\}} $$Since Term 1’s value ($51.417$) is greater than the calculated part of $r_{GB}$ ($49.125$), the final $r_P$ is determined by the defense requirements against interpolation attacks.\n$$ r_P \\approx 51.417 $$After rounding, we get $r_P = 52$.\nParameter Analysis: After verification, we can use the above calculation method as an assessment tool to evaluate the security of any set of analytical data. Below, we conduct security evaluations for the following two parameter sets.\nParameters: $t=2$, $d=1$, $c=0$, $α=5$, $\\kappa=128$, $p=381$\nPre-calculated common values:\n$\\min\\{\\kappa, \\log_2(p)\\} = \\min\\{128, 381\\} = 128$\n$\\log_2(\\alpha) = \\log_2(5) ≈ 2.322$\n$\\log_α(t) = \\log_5(2) = \\frac{\\log_2(2)} {\\log_2(5)} = 1 / 2.322 ≈ 0.4307$\n$\\log_α(2) = \\log_5(2) ≈ 0.4307$\nStep 1: Calculate $r_{GB}$ Calculation process:\nFirst sub-term of $r_{GB}$: $$ \\frac{\\min\\{\\log_2(p), \\kappa\\}}{\\log_2(\\alpha)} - r_F $$ $$ = \\frac{128}{2.322} - 6 $$ $$ \\quad\\quad\\quad~~~ \\approx 55.125 - 6 = 49.125 $$ Second sub-term of $r_{GB}$: $$t - 1 + \\log_{\\alpha}(2) \\cdot \\min\\left\\{ \\frac{\\kappa}{t+1}, \\frac{\\log_2(p)}{2} \\right\\} - r'_F$$First compute the $\\min{\\ldots}$ part:\n$$\\min\\left\\{ \\frac{128}{2+1}, \\frac{381}{2} \\right\\} = \\min\\{42.67, 190.5\\} = 42.67$$Then substitute into the full expression:\n$$ = 2 - 1 + 0.4307 \\cdot 42.67 - 3 $$ $$ \\approx 1 + 18.38 - 3 = 16.38 $$ Determine the Value of $r_{GB}$: $$ r_{GB} = \\max{\\{49.125, 16.38\\}} = 49.125 $$\nStep 2: Calculate the Final $r_P$ Now, $r_P$ is determined by taking the maximum of two other sub-terms and then rounding up.\nFirst sub-term of $r_P$ (resistance against algebraic attacks): $$ 1 + \\frac{\\min\\{\\kappa, \\log_2(p)\\}}{\\log_2(\\alpha)} + \\log_\\alpha(t) - r_F $$ $$ \\approx 1 + \\frac{128}{2.322} + 0.4307 - 6 $$ $$ \\approx 1 + 55.125 + 0.4307 - 6 $$ $$ = 56.5557 - 6 = 50.556 $$ Second sub-term of $r_P$ (resistance against GB attacks): This value is the $r_{GB}$ we calculated in the previous step. $$ r_{GB} = 49.125 $$ Determine the value of $r_P$: $$ r_P = \\lceil \\max\\{50.556, 49.125\\} \\rceil $$ $$ r_P = \\lceil 50.556 \\rceil $$ $$ r_P = 51 $$",
  "wordCount" : "956",
  "inLanguage": "zh",
  "datePublished": "2025-08-17T16:57:25+08:00",
  "dateModified": "2025-08-17T16:57:25+08:00",
  "author":{
    "@type": "Person",
    "name": "Sidereus Hu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sidereushu.github.io/posts/poseidon-hash-algebraic-attack-analysis-designers-perspective/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sidereus Hu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sidereushu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sidereushu.github.io/" accesskey="h" title="Sidereus Hu (Alt + H)">Sidereus Hu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sidereushu.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://sidereushu.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Poseidon Hash Algebraic Attack Analysis (Designer&#39;s Perspective)
    </h1>
    <div class="post-meta"><span title='2025-08-17 16:57:25 +0800 CST'>2025-08-17</span>&nbsp;·&nbsp;Sidereus Hu

</div>
  </header> 
  <div class="post-content"><br>
<p>In recent years, &ldquo;ZK-friendly&rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.</p>
<p>This article approaches from a designer&rsquo;s perspective, based on a recent paper [GKR25], presents some factual conclusions from that work, and provides supplementary analysis for certain conclusions.</p>
<table>
  <thead>
      <tr>
          <th>Related Work</th>
          <th>Core Method</th>
          <th>Effectiveness Analysis for Poseidon</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>[FP20]</strong></td>
          <td>Closed-form degree expressions</td>
          <td>Helpful for modeling Gröbner basis attacks</td>
      </tr>
      <tr>
          <td><strong>[BBLP22]</strong></td>
          <td>Skipping (multiple) full rounds</td>
          <td>Reduced actual nonlinear depth</td>
      </tr>
      <tr>
          <td><strong>[ABM24]</strong></td>
          <td>Round-level Gröbner basis modeling</td>
          <td>Shows underestimated vulnerabilities at κ = 1024</td>
      </tr>
      <tr>
          <td><strong>[BBL+24]</strong></td>
          <td>FreeLunch Gröbner basis attack</td>
          <td>Ineffective due to low S-box degree</td>
      </tr>
      <tr>
          <td><strong>[KLR24]</strong></td>
          <td>&ldquo;Six Worlds&rdquo; analysis framework</td>
          <td>Not yet applied to Poseidon, has potential research value</td>
      </tr>
      <tr>
          <td><strong>[GKR25]</strong></td>
          <td>Forward Gröbner basis attack utilizing subspace trajectories</td>
          <td>Original analysis shows overestimation or underestimation of required security rounds</td>
      </tr>
      <tr>
          <td><strong>[BBB+25]</strong></td>
          <td>Iterated Resultants</td>
          <td>Reducible to simple univariate cases</td>
      </tr>
  </tbody>
</table>
<p>[GKR25] is the latest work proposed by the Poseidon designers. This work provides the minimum partial rounds required for the Poseidon2 hash function to achieve 128-bit security in Sponge mode implementation, as shown in the figure below. The black line in the figure represents the parameter settings recommended by the Poseidon2 designers (where the dashed line indicates security redundancy of $+7.5\% \cdot r_{P}$), while other colored lines represent the authors&rsquo; test data for current mainstream attacks.</p>
<p><img loading="lazy" src="/images/GKR25_PartFig.png"></p>
<p>From the black line in the figure, we can see that the Poseidon authors recommend partial rounds $r_{P}$ values in the 52-53 range. This data is calculated from the following theoretical lower bound formula:</p>
$$ r_F = 6 ; (r_f = 3, ; r_f' = 3) , , $$$$ r_P = \left\lceil 
\max \left\{ \underbrace{1 + \frac{\min\{\kappa, \log_2(p)\}}{\log_2(\alpha)} + \log_{\alpha}(t) - r_F}_{\text{Term1}}, \; r_{GB} \right\}
\right\rceil ,  $$$$ r_{GB} = \max \left\{ 
\frac{\min\{\log_2(p), \kappa\}}{\log_2(\alpha)} - r_F, \; 
t - 1 + \log_{\alpha}(2) \cdot \min \left\{ \frac{\kappa}{t+1}, \frac{\log_2(p)}{2} \right\} - r_F' 
\right\} .$$<hr>
<br>
<h2 id="verification-of-poseidon-authors-results">Verification of Poseidon Authors&rsquo; results:<a hidden class="anchor" aria-hidden="true" href="#verification-of-poseidon-authors-results">#</a></h2>
<p>We first select a parameter set to verify whether we can confirm the authors&rsquo; results shown in the figure:</p>
<ul>
<li>
<p><strong>Parameters</strong>:</p>
<ul>
<li>$p \approx 2^{256}$ (therefore $\log_2(p) = 256$)</li>
<li>$\alpha = 5$</li>
<li>$t = 8$</li>
<li>$\kappa = 128$</li>
<li>$r_F = 6$ (we first ignore the security margin)</li>
</ul>
</li>
<li>
<p><strong>Calculate intermediate values</strong>:</p>
<ul>
<li>
<p>$\log_2(\alpha) = \log_2(5) \approx 2.322$</p>
</li>
<li>
<p>$\log_\alpha(t) = \log_5(8) = \frac{\log_2(8)}{\log_2(5)} = \frac{3}{2.322} \approx 1.292$</p>
</li>
</ul>
</li>
</ul>
<br>
<h3 id="step-1-compute-term-1-defense-against-interpolation-attacks">Step 1: Compute Term 1 (defense against interpolation attacks)<a hidden class="anchor" aria-hidden="true" href="#step-1-compute-term-1-defense-against-interpolation-attacks">#</a></h3>
$$ \mathrm{Term}  1 = 1 + \frac{\min\{128, 256\}}{2.322} + 1.292 - 6 $$<p> </p>
$$ = 1 + \frac{128}{2.322} + 1.292 - 6 $$<p> </p>
$$ \approx 1 + 55.125 + 1.292 - 6 $$<p> </p>
$$ \approx 51.417 $$<p>
<br></p>
<h3 id="step-2-compute-term-2-">Step 2: Compute Term 2 ($r_{GB}$)<a hidden class="anchor" aria-hidden="true" href="#step-2-compute-term-2-">#</a></h3>
<p>The formula for $r_{GB}$ also contains a $\max$ operation. We&rsquo;ll calculate its main components separately (temporarily ignoring the unknown $r'_{GB}$ in the formula):</p>
<ul>
<li><strong>First part of $r_{GB}$:</strong></li>
</ul>
$$ \frac{\min{\log_2(p), \kappa}}{\log_2(\alpha)} - r_F = \frac{\min\{256, 128\}}{2.322} - 6 \approx 55.125 - 6 = 49.125 $$<ul>
<li>
<p><strong>Second part of $r_{GB}$:</strong></p>
<ul>
<li>
<p>$\log_{\alpha}(2) = \frac{\log_2(2)}{\log_2(5)} = \frac{1}{2.322} \approx 0.431$</p>
</li>
<li>
<p>$\min\left\{\frac{\kappa}{t+1}, \frac{\log_2(p)}{2}\right\} = \min\left\{\frac{128}{8+1}, \frac{256}{2}\right\} = \min\{14.22, 128\} = 14.22$</p>
</li>
<li>
<p>$t - 1 + \log_{\alpha}(2) \cdot (14.22) - r_F = 8 - 1 + 0.431 \cdot 14.22 - 6 \approx 7 + 6.13 - 6 = 7.13$</p>
</li>
</ul>
</li>
</ul>
<p>Therefore, $r_{GB} = \max{\{49.125, 7.13\}}$. We can see that $r_{GB}$ is at least $49.125$.</p>
<br>
<h3 id="step-3-final--calculation">Step 3: Final $r_P$ Calculation<a hidden class="anchor" aria-hidden="true" href="#step-3-final--calculation">#</a></h3>
$$ r_P = \max{\{\text{Term } 1\},~~ r_{GB}} = \max{\{51.417, r_{GB}\}} $$<p>Since Term 1&rsquo;s value ($51.417$) is greater than the calculated part of $r_{GB}$ ($49.125$), the final $r_P$ is determined by the defense requirements against interpolation attacks.</p>
$$ r_P \approx 51.417 $$<p>After rounding, we get $r_P = 52$.</p>
<hr>
<br>
<h2 id="parameter-analysis">Parameter Analysis:<a hidden class="anchor" aria-hidden="true" href="#parameter-analysis">#</a></h2>
<p>After verification, we can use the above calculation method as an assessment tool to evaluate the security of any set of analytical data. Below, we conduct security evaluations for the following two parameter sets.</p>
<p><strong>Parameters</strong>: $t=2$, $d=1$, $c=0$, $α=5$, $\kappa=128$, $p=381$</p>
<p><strong>Pre-calculated common values</strong>:</p>
<ul>
<li>
<p>$\min\{\kappa, \log_2(p)\} = \min\{128, 381\} = 128$</p>
</li>
<li>
<p>$\log_2(\alpha) = \log_2(5) ≈ 2.322$</p>
</li>
<li>
<p>$\log_α(t) = \log_5(2) = \frac{\log_2(2)}  {\log_2(5)} = 1 / 2.322 ≈ 0.4307$</p>
</li>
<li>
<p>$\log_α(2) = \log_5(2) ≈ 0.4307$</p>
</li>
</ul>
<br>
<h4 id="step-1-calculate">Step 1: Calculate $r_{GB}$<a hidden class="anchor" aria-hidden="true" href="#step-1-calculate">#</a></h4>
<p>Calculation process:</p>
<ol>
<li><strong>First sub-term of $r_{GB}$:</strong></li>
</ol>
$$
\frac{\min\{\log_2(p), \kappa\}}{\log_2(\alpha)} - r_F
$$<p>
</p>
$$
= \frac{128}{2.322} - 6
$$<p>
</p>
$$
\quad\quad\quad~~~ \approx 55.125 - 6 = 49.125
$$<ol start="2">
<li><strong>Second sub-term of $r_{GB}$:</strong></li>
</ol>
$$t - 1 + \log_{\alpha}(2) \cdot \min\left\{ \frac{\kappa}{t+1}, \frac{\log_2(p)}{2} \right\} - r'_F$$<p>First compute the $\min{\ldots}$ part:</p>
$$\min\left\{ \frac{128}{2+1}, \frac{381}{2} \right\} = \min\{42.67, 190.5\} = 42.67$$<p>Then substitute into the full expression:</p>
$$
= 2 - 1 + 0.4307 \cdot 42.67 - 3
$$<p>
</p>
$$
\approx 1 + 18.38 - 3 = 16.38
$$<ol start="3">
<li><strong>Determine the Value of $r_{GB}$:</strong></li>
</ol>
$$ r_{GB} = \max{\{49.125, 16.38\}} = 49.125 $$<br>
<h4 id="step-2-calculate-the-final">Step 2: Calculate the Final $r_P$<a hidden class="anchor" aria-hidden="true" href="#step-2-calculate-the-final">#</a></h4>
<p>Now, $r_P$ is determined by taking the maximum of two other sub-terms and then rounding up.</p>
<ol>
<li><strong>First sub-term of $r_P$ (resistance against algebraic attacks):</strong></li>
</ol>
$$
1 + \frac{\min\{\kappa, \log_2(p)\}}{\log_2(\alpha)} + \log_\alpha(t) - r_F
$$<p>
</p>
$$
\approx 1 + \frac{128}{2.322} + 0.4307 - 6
$$<p>
</p>
$$
\approx 1 + 55.125 + 0.4307 - 6
$$<p>
</p>
$$
= 56.5557 - 6 = 50.556
$$<ol start="2">
<li><strong>Second sub-term of $r_P$ (resistance against GB attacks):</strong></li>
</ol>
<p>This value is the $r_{GB}$ we calculated in the previous step.
</p>
$$ r_{GB} = 49.125 $$<ol start="3">
<li><strong>Determine the value of $r_P$:</strong></li>
</ol>
$$
r_P = \lceil \max\{50.556, 49.125\} \rceil
$$<p>
</p>
$$
r_P = \lceil 50.556 \rceil
$$<p>
</p>
$$
r_P = 51
$$

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://sidereushu.github.io/">Sidereus Hu</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
