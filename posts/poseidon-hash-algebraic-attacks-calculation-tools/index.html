<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Poseidon Hash Algebraic Attacks (Calculation Tools) | Sidereus Hu</title>
<meta name="keywords" content="">
<meta name="description" content="
In recent years, &ldquo;ZK-friendly&rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have received widespread attention. They are typically based on carefully constructed algebraic structures to achieve lower constraint counts in arithmetic circuits, thereby enabling higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes potential attack surfaces under certain analysis models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques using subspace trails—have gained significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.">
<meta name="author" content="Sidereus Hu">
<link rel="canonical" href="https://sidereushu.github.io/posts/poseidon-hash-algebraic-attacks-calculation-tools/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css" integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sidereushu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sidereushu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sidereushu.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sidereushu.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://sidereushu.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://sidereushu.github.io/posts/poseidon-hash-algebraic-attacks-calculation-tools/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)'], ['$', '$']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
 


<meta property="og:url" content="https://sidereushu.github.io/posts/poseidon-hash-algebraic-attacks-calculation-tools/">
  <meta property="og:site_name" content="Sidereus Hu">
  <meta property="og:title" content="Poseidon Hash Algebraic Attacks (Calculation Tools)">
  <meta property="og:description" content="
In recent years, “ZK-friendly” hash functions designed for zero-knowledge proof (ZK) scenarios have received widespread attention. They are typically based on carefully constructed algebraic structures to achieve lower constraint counts in arithmetic circuits, thereby enabling higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes potential attack surfaces under certain analysis models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques using subspace trails—have gained significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-09-09T16:57:25+08:00">
    <meta property="article:modified_time" content="2025-09-09T16:57:25+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Poseidon Hash Algebraic Attacks (Calculation Tools)">
<meta name="twitter:description" content="
In recent years, &ldquo;ZK-friendly&rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have received widespread attention. They are typically based on carefully constructed algebraic structures to achieve lower constraint counts in arithmetic circuits, thereby enabling higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes potential attack surfaces under certain analysis models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques using subspace trails—have gained significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sidereushu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Poseidon Hash Algebraic Attacks (Calculation Tools)",
      "item": "https://sidereushu.github.io/posts/poseidon-hash-algebraic-attacks-calculation-tools/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Poseidon Hash Algebraic Attacks (Calculation Tools)",
  "name": "Poseidon Hash Algebraic Attacks (Calculation Tools)",
  "description": "\nIn recent years, \u0026ldquo;ZK-friendly\u0026rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have received widespread attention. They are typically based on carefully constructed algebraic structures to achieve lower constraint counts in arithmetic circuits, thereby enabling higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes potential attack surfaces under certain analysis models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques using subspace trails—have gained significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.\n",
  "keywords": [
    
  ],
  "articleBody": "\nIn recent years, “ZK-friendly” hash functions designed for zero-knowledge proof (ZK) scenarios have received widespread attention. They are typically based on carefully constructed algebraic structures to achieve lower constraint counts in arithmetic circuits, thereby enabling higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes potential attack surfaces under certain analysis models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques using subspace trails—have gained significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.\nThis article is based on a recent paper [GKR25] by the Poseidon designers, verifying the main conclusions related to the attack algorithms proposed in that work, making it our theoretical calculation tool.\nAnalysis Tool 1: Parameter Bounds Recommended by Poseidon Designers [GKR25] is the latest work proposed by the Poseidon designers. This work provides the minimum partial rounds required for the Poseidon2 hash function in Sponge mode to achieve 128-bit security in the figure below. The black line in the figure represents the parameter settings recommended by the Poseidon2 designers (where the dashed line includes a safety redundancy of +7.5% · rₚ), and the other colored lines are the current mainstream attack test data conducted by the authors.\nFrom the black line in the figure, we can see that the Partial rounds value rₚ recommended by the Poseidon authors is in the 52-53 range, and with safety redundancy, the rₚ value is in the 56-58 range. This data is calculated from the following theoretical lower bound formula:\n$$ r_F = 6 ; (r_f = 3, ; r_f' = 3) , , $$$$ r_P = \\left\\lceil \\max \\left\\{ \\underbrace{1 + \\frac{\\min\\{\\kappa, \\log_2(p)\\}}{\\log_2(\\alpha)} + \\log_{\\alpha}(t) - r_F}_{\\text{Term1}}, \\; r_{GB} \\right\\} \\right\\rceil , $$$$ r_{GB} = \\max \\left\\{ \\frac{\\min\\{\\log_2(p), \\kappa\\}}{\\log_2(\\alpha)} - r_F, \\; t - 1 + \\log_{\\alpha}(2) \\cdot \\min \\left\\{ \\frac{\\kappa}{t+1}, \\frac{\\log_2(p)}{2} \\right\\} - r_F' \\right\\} .$$Verification of Poseidon Authors’ Conclusions: We first select a set of parameters to see if we can verify the authors’ conclusions shown in the figure:\nParameters:\n$p \\approx 2^{256}$ (thus $\\log_2(p) = 256$) $\\alpha = 5$ $t = 8$ $\\kappa = 128$ $r_F = 6$ (we first don’t consider safety redundancy) Calculate intermediate values:\n$\\log_2(\\alpha) = \\log_2(5) \\approx 2.322$ $\\log_\\alpha(t) = \\log_5(8) = \\frac{\\log_2(8)}{\\log_2(5)} = \\frac{3}{2.322} \\approx 1.292$ Step 1: Calculate Term1 (Defense against interpolation attacks) $$ \\text{Term}1 = 1 + \\frac{\\min{\\{128, 256}\\}}{2.322} + 1.292 - 6 $$ $$ = 1 + \\frac{128}{2.322} + 1.292 - 6 $$ $$ \\approx 1 + 55.125 + 1.292 - 6 $$ $$ \\approx 51.417 $$Step 2: Calculate $r_{GB}$ The $r_{GB}$ formula also contains a max operation. We calculate its main components separately:\nFirst part of $r_{GB}$: $$ \\frac{\\min{\\{\\log_2(p), \\kappa}\\}}{\\log_2(\\alpha)} - r_F = \\frac{\\min{\\{256, 128}\\}}{2.322} - 6 \\approx 55.125 - 6 = 49.125 $$ Second part of $r_{GB}$:\n$\\log_{\\alpha}(2) = \\frac{\\log_2(2)}{\\log_2(5)} = \\frac{1}{2.322} \\approx 0.431$\n$\\min\\left\\{\\frac{\\kappa}{t+1}, \\frac{\\log_2(p)}{2}\\right\\} = \\min\\left\\{\\frac{128}{8+1}, \\frac{256}{2}\\right\\} = \\min\\{14.22, 128\\} = 14.22$\n$t - 1 + \\log_{\\alpha}(2) \\cdot (14.22) - r_F = 8 - 1 + 0.431 \\cdot 14.22 - 6 \\approx 7 + 6.13 - 6 = 7.13$\nTherefore, $r_{GB} = \\max{\\{49.125, 7.13\\}}$. We can see that $r_{GB}$ is at least $49.125$.\nStep 3: Final $r_P$ calculation $$ r_P = \\max{\\{\\text{Term1}, r_{GB}\\}} = \\max{\\{51.417, r_{GB}\\}} $$Since the value of Term1 (51.417) is greater than the calculated part of $r_{GB}$ (49.125), the final $r_P$ is determined by the defense requirements against interpolation attacks.\n$$ r_P \\approx 51.417 $$After rounding up, we get $r_P = 52$. This result matches the authors’ recommended parameter range. If we add the 7.5% safety margin, then the final partial rounds would be:\n$$\\lceil 52+52\\times 7.5\\% \\rceil = \\lceil 55.9 \\rceil = 56$$Parameter Analysis: After verification, we can now use the above analysis method as an analysis tool to conduct security assessments for any set of analysis data. For example, below we perform a security assessment for the following set of parameters.\nParameters: $t=2$, $d=1$, $c=0$, $α=5$, $\\kappa=128$, $p=381$\nPre-calculated common values:\n$\\min{\\{\\kappa, \\log_2(p)\\}} = \\min{\\{128, 381\\}} = 128$ $\\log_2(\\alpha) = \\log_2(5) \\approx 2.322$ $\\log_\\alpha(t) = \\log_5(2) = \\log_2(2) / \\log_2(5) = 1 / 2.322 \\approx 0.4307$ $\\log_\\alpha(2) = \\log_5(2) \\approx 0.4307$ Step 1: Calculate $r_{GB}$ Calculation process:\nFirst subterm of $r_{GB}$: $$ \\frac{\\min{\\{\\log_2(p), \\kappa}\\}}{\\log_2(\\alpha)} - r_F $$ $$ = \\frac{128}{2.322} - 6 $$ $$ \\approx 55.125 - 6 = 49.125 $$ Second subterm of $r_{GB}$: $$t - 1 + \\log_{\\alpha}(2) \\cdot \\min\\left\\{ \\frac{\\kappa}{t+1}, \\frac{\\log_2(p)}{2} \\right\\} - r'_F$$First calculate the $\\min{\\ldots}$ part:\n$$\\min\\left\\{ \\frac{128}{2+1}, \\frac{381}{2} \\right\\} = \\min\\{42.67, 190.5\\} = 42.67$$Then substitute into the complete expression:\n$$ = 2 - 1 + 0.4307 \\cdot 42.67 - 3 $$ $$ \\approx 1 + 18.38 - 3 = 16.38 $$ Determine the value of $r_{GB}$: $$ r_{GB} = \\max{\\{49.125, 16.38\\}} = 49.125 $$Step 2: Calculate final $r_P$ Now, $r_P$ is determined by taking the maximum of the other two subterms and then rounding up.\nFirst subterm of $r_P$ (resistance against algebraic attacks): $$ 1 + \\frac{\\min{\\{\\kappa, \\log_2(p)}\\}}{\\log_2(\\alpha)} + \\log_\\alpha(t) - r_F $$ $$ \\approx 1 + \\frac{128}{2.322} + 0.4307 - 6 $$ $$ \\approx 1 + 55.125 + 0.4307 - 6 $$ $$ = 56.5557 - 6 = 50.556 $$ Second subterm of $r_P$ (resistance against GB attacks): This value is the $r_{GB}$ we calculated in the previous step. $$ r_{GB} = 49.125 $$ Determine the value of $r_P$: $$ r_P = \\lceil \\max{\\{50.556, 49.125\\}} \\rceil $$ $$ r_P = \\lceil 50.556 \\rceil $$ $$ r_P = 51 $$The result of $r_P = 51$ matches the authors’ recommended parameter range. If we add the 7.5% safety margin, then the final partial rounds would be:\n$$\\lceil 51+51\\times 7.5\\% \\rceil = \\lceil 54.825 \\rceil = 55$$\nAnalysis Tool 2: Analysis of the Improved Attack Algorithm Proposed in [GKR25] The improved attack algorithm proposed by the [GKR25] authors is based on the original GB attack algorithm and proposes a forward GB attack algorithm. The attack model Model 1 (FW) it adopts is shown in the following screenshot from the original paper:\nVerification of Poseidon Authors’ Conclusions: We first select a set of parameters from Table 3 to see if we can verify the corresponding conclusions in the table. Before this, we restate our goal: find the minimum integer $r_P$ such that the attack complexity $C_{GB} ≥ 2^{128}$.\nCorresponding inequality to be verified: $$\\left(1 + 2\\sqrt{t - d + \\alpha} \\cdot r_F + \\frac{r_p^\\ell}{2}\\right)^2 \\geq 2^{128}$$ Corresponding equivalent condition after transformation: $$\\left(1 + 2\\sqrt{t - d + \\alpha} \\cdot r_F + \\frac{r_p^\\ell}{2}\\right) \\geq 2^{64}$$ Test Case 1 We selected the $t=8$ row from the first part of Table 3 ($p \\approx 2^{96}, d=3$).\nTable 3 target value: $r_p = 2 - 5$\nKnown parameters:\n$t = 8, d = 3, \\alpha = 3$ $R_F = 6 \\rightarrow r_F = 3$ According to Table3’s sponge mode setting, $c = d = 3$ Derived parameters:\n$r = t - c = 8 - 3 = 5$ $\\ell = r - d = 5 - 3 = 2$ Calculation Process: Substitute the parameters into our inequality condition:\n$$\\left( \\frac{1 + 2\\sqrt{8 \\cdot 3 \\cdot 3^{r_p / 2}}}{8 + 3} \\right) \\geq 2^{64}$$$$\\left( \\frac{1 + 2\\sqrt{24 \\cdot 3^{2 + 0.5 r_p}}}{11} \\right) \\geq 2^{64}$$We solve this inequality for $r_p$. Let $N$ such that $(N) \\geq 2^{64}$.\nUsing approximation $N^{11} \\geq 2^{64}$, we get $N \\geq (11! \\cdot 2^{64})^{1/11}$.\nAfter a series of logarithmic operations and algebraic simplifications (process similar to the previous calculation): $$1+9.798 \\cdot 3^{2+0.5r_P} \\ge 4.9 \\cdot 2^{5.818}$$$$0.7925 \\cdot r_P \\ge 1.658$$$$r_P \\ge 2.09$$Conclusion: The calculation requires $r_P$ to be greater than or equal to 2.09, which rounds up to $r_P = 3$. Table 3 gives the range as $2-5$. Our calculation result 3 falls within this range.\nTest Case 2 We selected the parameters corresponding to the $t=16$ row in Table3 with $p ≈ 2^{128}$, $d=2$.\nTable 3 target value: $r_p = 12$\nKnown parameters:\n$t = 16, d = 2, \\alpha = 3$ $R_F = 6 \\rightarrow r_F = 3$ According to Table3’s sponge mode setting, $c = d = 2$ Derived parameters:\n$r = t - c = 16 - 2 = 14$ $\\ell = r - d = 14 - 2 = 12$ The calculation process is the same as Test Case 1. The calculation result is $r_p = 11$, which differs from the target value $r_p = 12$ by only one round.\nTest Case 3 We selected the parameters corresponding to the $t=24$ row in Table3 with $p ≈ 2^{256}$, $d=1$.\nTable 3 target value: $r_p = 22$\nKnown parameters:\n$t = 24, d = 1, \\alpha = 3$ $R_F = 6 \\rightarrow r_F = 3$ According to Table3’s sponge mode setting, $c = d = 1$ Derived parameters:\n$r = t - c = 24 - 1 = 23$ $\\ell = r - d = 23 - 1 = 22$ The calculation process is the same as Test Case 1. The calculation result is $r_p = 21$, which also differs from the target value $r_p = 22$ by only one round.\nTest Case 4 We selected the parameters corresponding to the $t=12$ row in Table3 with $p ≈ 2^{256}$, $d=1$.\nTable 3 target value: $r_p = 10$\nKnown parameters:\n$t = 12, d = 1, \\alpha = 5$ $R_F = 6 \\rightarrow r_F = 3$ According to Table3’s sponge mode setting, $c = d = 1$ Derived parameters:\n$r = t - c = 12 - 1 = 11$ $\\ell = r - d = 11 - 1 = 10$ The calculation process is the same as Test Case 1. The calculation result is $r_p = 9$, which still differs from the target value $r_p = 10$ by only one round.\nParameter Analysis: After verification, we can now use the above analysis method as an analysis tool to conduct security assessments for any set of analysis data. For example, below we perform a security assessment for the following set of parameters.\nParameters to Calculate: State width: $t = 2$ Mode: compress, $c = 0$ Rate: $r = t - c = 2$ Security requirement: $\\kappa=128$ Modulus: $p=381$ Output length: $d = 1$ Full rounds: $R_F = 6 \\implies$ half full rounds $r_F = 3$ S-box: $\\alpha = 5$ Known constants: Attack complexity exponent: $\\omega = 2$ Intermediate variables: Subspace trail length: $\\ell = r - d = 2 - 1 = 1$ Target formula: The attack cost $C_{GB}$ must reach the security target of $2^{128}$.\n$$ C_{GB} \\approx \\left( \\binom{ 1 + 2\\sqrt{t \\cdot d} \\cdot \\alpha^{r_F + \\frac{r_P - \\ell}{2}} }{ t + d } \\right)^{\\omega} \\geq 2^{128} $$Substitute parameters and establish inequality: Substituting the above parameters into the formula:\n$$ \\left( \\binom{ 1 + 2\\sqrt{2 \\cdot 1} \\cdot 5^{3 + \\frac{r_P - 1}{2}} }{ 2 + 1 } \\right)^2 \\geq 2^{128} $$Solve for $r_P$ First, take the square root of both sides: $$ \\left( \\frac{1 + 2\\sqrt{2} \\cdot 5^{2.5+0.5\\cdot r_P}}{3} \\right) \\geq 2^{64} $$ For convenience, let the upper term of the binomial coefficient (that longer expression) be $N$: $$ N = 1 + 2\\sqrt{2} \\cdot 5^{2.5+0.5\\cdot r_P} $$ Then the inequality becomes: $$ \\binom{N}{3} \\geq 2^{64} $$ When $N$ is much larger than $k$, the binomial coefficient can be approximated as: $$ \\binom{N}{k} \\approx \\frac{N^k}{k!} $$ Therefore, $$ \\frac{N^3}{3!} \\geq 2^{64} \\implies \\frac{N^3}{6} \\geq 2^{64} $$ Rearranging: $$ N^3 \\geq 6 \\cdot 2^{64} $$ Taking the cube root of both sides: $$ N \\geq \\sqrt[3]{6 \\cdot 2^{64}} = \\sqrt[3]{6} \\cdot 2^{64/3} $$ Calculate the approximate value of the right side: $$ \\sqrt[3]{6} \\approx 1.817, \\quad 2^{64/3} \\approx 2^{21.333} $$ So, $$ N \\geq 1.817 \\cdot 2^{21.333} $$ Now, we substitute back the expression for $N$ to solve for $r_P$: $$ 1 + 2\\sqrt{2} \\cdot 5^{2.5+0.5\\cdot r_P} \\geq 1.817 \\cdot 2^{21.333} $$ The +1 on the left side can be ignored in the face of such large numbers. Taking the base-2 logarithm $\\log_2$ of both sides: $$ \\log_2 (2\\sqrt{2}) + (2.5 + 0.5 \\cdot r_P) \\log_2 (5) \\geq \\log_2 (1.817) + 21.333 $$ Substituting common logarithm values: $$ \\log_2 (2\\sqrt{2}) = 1.5, \\quad \\log_2 (5) \\approx 2.322, \\quad \\log_2 (1.817) \\approx 0.862 $$ $$ 1.5 + (2.5 + 0.5 \\cdot r_P) \\cdot 2.322 \\geq 0.862 + 21.333 $$ $$ 1.5 + 5.805 + 1.161 \\cdot r_P \\geq 22.195 $$ $$ 7.305 + 1.161 \\cdot r_P \\geq 22.195 $$ $$ 1.161 \\cdot r_P \\geq 14.89 $$ $$ \\lceil r_P \\rceil \\geq \\Bigg\\lceil \\frac{14.89}{1.161} \\Bigg\\rceil \\approx \\lceil 12.825 \\rceil = 13 $$ Under the parameter settings we provided, after correctly interpreting the FW-GB attack cost formula, to achieve 128-bit security, the required partial rounds value is: $$r_{P}=13$$ ",
  "wordCount" : "2102",
  "inLanguage": "zh",
  "datePublished": "2025-09-09T16:57:25+08:00",
  "dateModified": "2025-09-09T16:57:25+08:00",
  "author":{
    "@type": "Person",
    "name": "Sidereus Hu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sidereushu.github.io/posts/poseidon-hash-algebraic-attacks-calculation-tools/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sidereus Hu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sidereushu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sidereushu.github.io/" accesskey="h" title="Sidereus Hu (Alt + H)">Sidereus Hu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sidereushu.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://sidereushu.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Poseidon Hash Algebraic Attacks (Calculation Tools)
    </h1>
    <div class="post-meta"><span title='2025-09-09 16:57:25 +0800 CST'>2025-09-09</span>&nbsp;·&nbsp;Sidereus Hu

</div>
  </header> 
  <div class="post-content"><br>
<p>In recent years, &ldquo;ZK-friendly&rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have received widespread attention. They are typically based on carefully constructed algebraic structures to achieve lower constraint counts in arithmetic circuits, thereby enabling higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes potential attack surfaces under certain analysis models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques using subspace trails—have gained significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.</p>
<p>This article is based on a recent paper [GKR25] by the Poseidon designers, verifying the main conclusions related to the attack algorithms proposed in that work, making it our theoretical calculation tool.</p>
<h2 id="analysis-tool-1-parameter-bounds-recommended-by-poseidon-designers">Analysis Tool 1: Parameter Bounds Recommended by Poseidon Designers<a hidden class="anchor" aria-hidden="true" href="#analysis-tool-1-parameter-bounds-recommended-by-poseidon-designers">#</a></h2>
<p>[GKR25] is the latest work proposed by the Poseidon designers. This work provides the minimum partial rounds required for the Poseidon2 hash function in Sponge mode to achieve 128-bit security in the figure below. The black line in the figure represents the parameter settings recommended by the Poseidon2 designers (where the dashed line includes a safety redundancy of +7.5% · rₚ), and the other colored lines are the current mainstream attack test data conducted by the authors.</p>
<p><img loading="lazy" src="/images/GKR25_PartFig.png"></p>
<p>From the black line in the figure, we can see that the Partial rounds value rₚ recommended by the Poseidon authors is in the 52-53 range, and with safety redundancy, the rₚ value is in the 56-58 range. This data is calculated from the following theoretical lower bound formula:</p>
$$ r_F = 6 ; (r_f = 3, ; r_f' = 3) , , $$$$ r_P = \left\lceil 
\max \left\{ \underbrace{1 + \frac{\min\{\kappa, \log_2(p)\}}{\log_2(\alpha)} + \log_{\alpha}(t) - r_F}_{\text{Term1}}, \; r_{GB} \right\}
\right\rceil ,  $$$$ r_{GB} = \max \left\{ 
\frac{\min\{\log_2(p), \kappa\}}{\log_2(\alpha)} - r_F, \; 
t - 1 + \log_{\alpha}(2) \cdot \min \left\{ \frac{\kappa}{t+1}, \frac{\log_2(p)}{2} \right\} - r_F' 
\right\} .$$<h2 id="verification-of-poseidon-authors-conclusions">Verification of Poseidon Authors&rsquo; Conclusions:<a hidden class="anchor" aria-hidden="true" href="#verification-of-poseidon-authors-conclusions">#</a></h2>
<p>We first select a set of parameters to see if we can verify the authors&rsquo; conclusions shown in the figure:</p>
<ul>
<li>
<p><strong>Parameters</strong>:</p>
<ul>
<li>$p \approx 2^{256}$ (thus $\log_2(p) = 256$)</li>
<li>$\alpha = 5$</li>
<li>$t = 8$</li>
<li>$\kappa = 128$</li>
<li>$r_F = 6$ (we first don&rsquo;t consider safety redundancy)</li>
</ul>
</li>
<li>
<p><strong>Calculate intermediate values</strong>:</p>
<ul>
<li>$\log_2(\alpha) = \log_2(5) \approx 2.322$</li>
<li>$\log_\alpha(t) = \log_5(8) = \frac{\log_2(8)}{\log_2(5)} = \frac{3}{2.322} \approx 1.292$</li>
</ul>
</li>
</ul>
<h3 id="step-1-calculate-term1-defense-against-interpolation-attacks"><strong>Step 1: Calculate Term1 (Defense against interpolation attacks)</strong><a hidden class="anchor" aria-hidden="true" href="#step-1-calculate-term1-defense-against-interpolation-attacks">#</a></h3>
$$ \text{Term}1 = 1 + \frac{\min{\{128, 256}\}}{2.322} + 1.292 - 6 $$<p> </p>
$$ = 1 + \frac{128}{2.322} + 1.292 - 6 $$<p> </p>
$$ \approx 1 + 55.125 + 1.292 - 6 $$<p> </p>
$$ \approx 51.417 $$<h3 id="step-2-calculate">Step 2: Calculate $r_{GB}$<a hidden class="anchor" aria-hidden="true" href="#step-2-calculate">#</a></h3>
<p>The $r_{GB}$ formula also contains a max operation. We calculate its main components separately:</p>
<ul>
<li><strong>First part of $r_{GB}$:</strong></li>
</ul>
$$ \frac{\min{\{\log_2(p), \kappa}\}}{\log_2(\alpha)} - r_F = \frac{\min{\{256, 128}\}}{2.322} - 6 \approx 55.125 - 6 = 49.125 $$<ul>
<li>
<p><strong>Second part of $r_{GB}$:</strong></p>
<ul>
<li>
<p>$\log_{\alpha}(2) = \frac{\log_2(2)}{\log_2(5)} = \frac{1}{2.322} \approx 0.431$</p>
</li>
<li>
<p>$\min\left\{\frac{\kappa}{t+1}, \frac{\log_2(p)}{2}\right\} = \min\left\{\frac{128}{8+1}, \frac{256}{2}\right\} = \min\{14.22, 128\} = 14.22$</p>
</li>
<li>
<p>$t - 1 + \log_{\alpha}(2) \cdot (14.22) - r_F = 8 - 1 + 0.431 \cdot 14.22 - 6 \approx 7 + 6.13 - 6 = 7.13$</p>
</li>
</ul>
</li>
</ul>
<p>Therefore, $r_{GB} = \max{\{49.125, 7.13\}}$. We can see that $r_{GB}$ is at least $49.125$.</p>
<h3 id="step-3-final--calculation">Step 3: Final $r_P$ calculation<a hidden class="anchor" aria-hidden="true" href="#step-3-final--calculation">#</a></h3>
$$ r_P = \max{\{\text{Term1}, r_{GB}\}} = \max{\{51.417, r_{GB}\}} $$<p>Since the value of Term1 (51.417) is greater than the calculated part of $r_{GB}$ (49.125), the final $r_P$ is determined by the defense requirements against interpolation attacks.</p>
$$ r_P \approx 51.417 $$<p>After rounding up, we get $r_P = 52$. This result matches the authors&rsquo; recommended parameter range. If we add the 7.5% safety margin, then the final partial rounds would be:</p>
$$\lceil 52+52\times 7.5\% \rceil = \lceil 55.9 \rceil = 56$$<h2 id="parameter-analysis">Parameter Analysis:<a hidden class="anchor" aria-hidden="true" href="#parameter-analysis">#</a></h2>
<p>After verification, we can now use the above analysis method as an analysis tool to conduct security assessments for any set of analysis data. For example, below we perform a security assessment for the following set of parameters.</p>
<p><strong>Parameters</strong>: $t=2$, $d=1$, $c=0$, $α=5$, $\kappa=128$, $p=381$</p>
<p><strong>Pre-calculated common values</strong>:</p>
<ul>
<li>$\min{\{\kappa, \log_2(p)\}} = \min{\{128, 381\}} = 128$</li>
<li>$\log_2(\alpha) = \log_2(5) \approx 2.322$</li>
<li>$\log_\alpha(t) = \log_5(2) = \log_2(2) / \log_2(5) = 1 / 2.322 \approx 0.4307$</li>
<li>$\log_\alpha(2) = \log_5(2) \approx 0.4307$</li>
</ul>
<h4 id="step-1-calculate">Step 1: Calculate $r_{GB}$<a hidden class="anchor" aria-hidden="true" href="#step-1-calculate">#</a></h4>
<p>Calculation process:</p>
<ol>
<li><strong>First subterm of $r_{GB}$:</strong></li>
</ol>
$$ \frac{\min{\{\log_2(p), \kappa}\}}{\log_2(\alpha)} - r_F $$<p> </p>
$$ = \frac{128}{2.322} - 6 $$<p> </p>
$$ \approx 55.125 - 6 = 49.125 $$<ol start="2">
<li><strong>Second subterm of $r_{GB}$:</strong></li>
</ol>
$$t - 1 + \log_{\alpha}(2) \cdot \min\left\{ \frac{\kappa}{t+1}, \frac{\log_2(p)}{2} \right\} - r'_F$$<p>First calculate the $\min{\ldots}$ part:</p>
$$\min\left\{ \frac{128}{2+1}, \frac{381}{2} \right\} = \min\{42.67, 190.5\} = 42.67$$<p>Then substitute into the complete expression:</p>
$$ = 2 - 1 + 0.4307 \cdot 42.67 - 3 $$<p> </p>
$$ \approx 1 + 18.38 - 3 = 16.38 $$<ol start="3">
<li><strong>Determine the value of $r_{GB}$:</strong></li>
</ol>
$$ r_{GB} = \max{\{49.125, 16.38\}} = 49.125 $$<h4 id="step-2-calculate-final">Step 2: Calculate final $r_P$<a hidden class="anchor" aria-hidden="true" href="#step-2-calculate-final">#</a></h4>
<p>Now, $r_P$ is determined by taking the maximum of the other two subterms and then rounding up.</p>
<ol>
<li><strong>First subterm of $r_P$ (resistance against algebraic attacks):</strong></li>
</ol>
$$ 1 + \frac{\min{\{\kappa, \log_2(p)}\}}{\log_2(\alpha)} + \log_\alpha(t) - r_F $$<p> </p>
$$ \approx 1 + \frac{128}{2.322} + 0.4307 - 6 $$<p> </p>
$$ \approx 1 + 55.125 + 0.4307 - 6 $$<p> </p>
$$ = 56.5557 - 6 = 50.556 $$<ol start="2">
<li><strong>Second subterm of $r_P$ (resistance against GB attacks):</strong></li>
</ol>
<p>This value is the $r_{GB}$ we calculated in the previous step. </p>
$$ r_{GB} = 49.125 $$<ol start="3">
<li><strong>Determine the value of $r_P$:</strong></li>
</ol>
$$ r_P = \lceil \max{\{50.556, 49.125\}} \rceil $$<p> </p>
$$ r_P = \lceil 50.556 \rceil $$<p> </p>
$$ r_P = 51 $$<p>The result of $r_P = 51$ matches the authors&rsquo; recommended parameter range. If we add the 7.5% safety margin, then the final partial rounds would be:</p>
$$\lceil 51+51\times 7.5\% \rceil = \lceil 54.825 \rceil = 55$$<br>
<h2 id="analysis-tool-2-analysis-of-the-improved-attack-algorithm-proposed-in-gkr25">Analysis Tool 2: Analysis of the Improved Attack Algorithm Proposed in [GKR25]<a hidden class="anchor" aria-hidden="true" href="#analysis-tool-2-analysis-of-the-improved-attack-algorithm-proposed-in-gkr25">#</a></h2>
<p>The improved attack algorithm proposed by the [GKR25] authors is based on the original GB attack algorithm and proposes a forward GB attack algorithm. The attack model Model 1 (FW) it adopts is shown in the following screenshot from the original paper:</p>
<p><img loading="lazy" src="/images/GKR25_FWModel.png"></p>
<h2 id="verification-of-poseidon-authors-conclusions-1">Verification of Poseidon Authors&rsquo; Conclusions:<a hidden class="anchor" aria-hidden="true" href="#verification-of-poseidon-authors-conclusions-1">#</a></h2>
<p><img loading="lazy" src="/images/GKR25_Table3.png"></p>
<p>We first select a set of parameters from Table 3 to see if we can verify the corresponding conclusions in the table. Before this, we restate our goal: find the minimum integer $r_P$ such that the attack complexity $C_{GB} ≥ 2^{128}$.</p>
<ul>
<li>
<p>Corresponding inequality to be verified: </p>
$$\left(1 + 2\sqrt{t - d + \alpha} \cdot r_F + \frac{r_p^\ell}{2}\right)^2 \geq 2^{128}$$</li>
<li>
<p>Corresponding equivalent condition after transformation: </p>
$$\left(1 + 2\sqrt{t - d + \alpha} \cdot r_F + \frac{r_p^\ell}{2}\right) \geq 2^{64}$$</li>
</ul>
<h2 id="test-case-1">Test Case 1<a hidden class="anchor" aria-hidden="true" href="#test-case-1">#</a></h2>
<p>We selected the $t=8$ row from the first part of Table 3 ($p \approx 2^{96}, d=3$).</p>
<ul>
<li>
<p>Table 3 target value: $r_p = 2 - 5$</p>
</li>
<li>
<p>Known parameters:</p>
<ul>
<li>$t = 8, d = 3, \alpha = 3$</li>
<li>$R_F = 6 \rightarrow r_F = 3$</li>
<li>According to Table3&rsquo;s sponge mode setting, $c = d = 3$</li>
</ul>
</li>
<li>
<p>Derived parameters:</p>
<ul>
<li>$r = t - c = 8 - 3 = 5$</li>
<li>$\ell = r - d = 5 - 3 = 2$</li>
</ul>
</li>
</ul>
<h2 id="calculation-process">Calculation Process:<a hidden class="anchor" aria-hidden="true" href="#calculation-process">#</a></h2>
<p>Substitute the parameters into our inequality condition:</p>
$$\left( \frac{1 + 2\sqrt{8 \cdot 3 \cdot 3^{r_p / 2}}}{8 + 3} \right) \geq 2^{64}$$$$\left( \frac{1 + 2\sqrt{24 \cdot 3^{2 + 0.5 r_p}}}{11} \right) \geq 2^{64}$$<p>We solve this inequality for $r_p$. Let $N$ such that $(N) \geq 2^{64}$.</p>
<p>Using approximation $N^{11} \geq 2^{64}$, we get $N \geq (11! \cdot 2^{64})^{1/11}$.</p>
<p>After a series of logarithmic operations and algebraic simplifications (process similar to the previous calculation): </p>
$$1+9.798 \cdot 3^{2+0.5r_P} \ge 4.9 \cdot 2^{5.818}$$$$0.7925 \cdot r_P \ge 1.658$$$$r_P \ge 2.09$$<p><strong>Conclusion</strong>: The calculation requires $r_P$ to be greater than or equal to 2.09, which rounds up to $r_P = 3$. Table 3 gives the range as $2-5$. Our calculation result <strong>3</strong> falls within this range.</p>
<h2 id="test-case-2">Test Case 2<a hidden class="anchor" aria-hidden="true" href="#test-case-2">#</a></h2>
<p>We selected the parameters corresponding to the $t=16$ row in Table3 with $p ≈ 2^{128}$, $d=2$.</p>
<ul>
<li>
<p>Table 3 target value: $r_p = 12$</p>
</li>
<li>
<p>Known parameters:</p>
<ul>
<li>$t = 16, d = 2, \alpha = 3$</li>
<li>$R_F = 6 \rightarrow r_F = 3$</li>
<li>According to Table3&rsquo;s sponge mode setting, $c = d = 2$</li>
</ul>
</li>
<li>
<p>Derived parameters:</p>
<ul>
<li>$r = t - c = 16 - 2 = 14$</li>
<li>$\ell = r - d = 14 - 2 = 12$</li>
</ul>
</li>
</ul>
<p>The calculation process is the same as Test Case 1. The calculation result is $r_p = 11$, which differs from the target value $r_p = 12$ by only one round.</p>
<h2 id="test-case-3">Test Case 3<a hidden class="anchor" aria-hidden="true" href="#test-case-3">#</a></h2>
<p>We selected the parameters corresponding to the $t=24$ row in Table3 with $p ≈ 2^{256}$, $d=1$.</p>
<ul>
<li>
<p>Table 3 target value: $r_p = 22$</p>
</li>
<li>
<p>Known parameters:</p>
<ul>
<li>$t = 24, d = 1, \alpha = 3$</li>
<li>$R_F = 6 \rightarrow r_F = 3$</li>
<li>According to Table3&rsquo;s sponge mode setting, $c = d = 1$</li>
</ul>
</li>
<li>
<p>Derived parameters:</p>
<ul>
<li>$r = t - c = 24 - 1 = 23$</li>
<li>$\ell = r - d = 23 - 1 = 22$</li>
</ul>
</li>
</ul>
<p>The calculation process is the same as Test Case 1. The calculation result is $r_p = 21$, which also differs from the target value $r_p = 22$ by only one round.</p>
<h2 id="test-case-4">Test Case 4<a hidden class="anchor" aria-hidden="true" href="#test-case-4">#</a></h2>
<p>We selected the parameters corresponding to the $t=12$ row in Table3 with $p ≈ 2^{256}$, $d=1$.</p>
<ul>
<li>
<p>Table 3 target value: $r_p = 10$</p>
</li>
<li>
<p>Known parameters:</p>
<ul>
<li>$t = 12, d = 1, \alpha = 5$</li>
<li>$R_F = 6 \rightarrow r_F = 3$</li>
<li>According to Table3&rsquo;s sponge mode setting, $c = d = 1$</li>
</ul>
</li>
<li>
<p>Derived parameters:</p>
<ul>
<li>$r = t - c = 12 - 1 = 11$</li>
<li>$\ell = r - d = 11 - 1 = 10$</li>
</ul>
</li>
</ul>
<p>The calculation process is the same as Test Case 1. The calculation result is $r_p = 9$, which still differs from the target value $r_p = 10$ by only one round.</p>
<br>
<h1 id="parameter-analysis-1">Parameter Analysis:<a hidden class="anchor" aria-hidden="true" href="#parameter-analysis-1">#</a></h1>
<p>After verification, we can now use the above analysis method as an analysis tool to conduct security assessments for any set of analysis data. For example, below we perform a security assessment for the following set of parameters.</p>
<h3 id="parameters-to-calculate">Parameters to Calculate:<a hidden class="anchor" aria-hidden="true" href="#parameters-to-calculate">#</a></h3>
<ul>
<li>State width: $t = 2$</li>
<li>Mode: compress, $c = 0$</li>
<li>Rate: $r = t - c = 2$</li>
<li>Security requirement: $\kappa=128$</li>
<li>Modulus: $p=381$</li>
<li>Output length: $d = 1$</li>
<li>Full rounds: $R_F = 6 \implies$ half full rounds $r_F = 3$</li>
<li>S-box: $\alpha = 5$</li>
</ul>
<h4 id="known-constants">Known constants:<a hidden class="anchor" aria-hidden="true" href="#known-constants">#</a></h4>
<ul>
<li>Attack complexity exponent: $\omega = 2$</li>
</ul>
<h5 id="intermediate-variables">Intermediate variables:<a hidden class="anchor" aria-hidden="true" href="#intermediate-variables">#</a></h5>
<ul>
<li>Subspace trail length: $\ell = r - d = 2 - 1 = 1$</li>
</ul>
<h4 id="target-formula">Target formula:<a hidden class="anchor" aria-hidden="true" href="#target-formula">#</a></h4>
<p>The attack cost $C_{GB}$ must reach the security target of $2^{128}$.</p>
$$ C_{GB} \approx \left( \binom{ 1 + 2\sqrt{t \cdot d} \cdot \alpha^{r_F + \frac{r_P - \ell}{2}} }{ t + d } \right)^{\omega} \geq 2^{128} $$<h3 id="substitute-parameters-and-establish-inequality">Substitute parameters and establish inequality:<a hidden class="anchor" aria-hidden="true" href="#substitute-parameters-and-establish-inequality">#</a></h3>
<p>Substituting the above parameters into the formula:</p>
$$ \left( \binom{ 1 + 2\sqrt{2 \cdot 1} \cdot 5^{3 + \frac{r_P - 1}{2}} }{ 2 + 1 } \right)^2 \geq 2^{128} $$<h3 id="solve-for">Solve for $r_P$<a hidden class="anchor" aria-hidden="true" href="#solve-for">#</a></h3>
<ul>
<li>First, take the square root of both sides:</li>
</ul>
$$ \left( \frac{1 + 2\sqrt{2} \cdot 5^{2.5+0.5\cdot r_P}}{3} \right) \geq 2^{64} $$<ul>
<li>
<p>For convenience, let the upper term of the binomial coefficient (that longer expression) be $N$: </p>
$$ N = 1 + 2\sqrt{2} \cdot 5^{2.5+0.5\cdot r_P} $$<p> Then the inequality becomes: </p>
$$ \binom{N}{3} \geq 2^{64} $$</li>
<li>
<p>When $N$ is much larger than $k$, the binomial coefficient can be approximated as: </p>
$$ \binom{N}{k} \approx \frac{N^k}{k!} $$<p> Therefore, </p>
$$ \frac{N^3}{3!} \geq 2^{64} \implies \frac{N^3}{6} \geq 2^{64} $$</li>
<li>
<p>Rearranging: </p>
$$ N^3 \geq 6 \cdot 2^{64} $$</li>
<li>
<p>Taking the cube root of both sides: </p>
$$ N \geq \sqrt[3]{6 \cdot 2^{64}} = \sqrt[3]{6} \cdot 2^{64/3} $$</li>
<li>
<p>Calculate the approximate value of the right side: </p>
$$ \sqrt[3]{6} \approx 1.817, \quad 2^{64/3} \approx 2^{21.333} $$<p> So, </p>
$$ N \geq 1.817 \cdot 2^{21.333} $$</li>
<li>
<p>Now, we substitute back the expression for $N$ to solve for $r_P$: </p>
$$ 1 + 2\sqrt{2} \cdot 5^{2.5+0.5\cdot r_P} \geq 1.817 \cdot 2^{21.333} $$</li>
<li>
<p>The +1 on the left side can be ignored in the face of such large numbers. Taking the base-2 logarithm $\log_2$ of both sides: </p>
$$ \log_2 (2\sqrt{2}) + (2.5 + 0.5 \cdot r_P) \log_2 (5) \geq \log_2 (1.817) + 21.333 $$</li>
<li>
<p>Substituting common logarithm values: </p>
$$ \log_2 (2\sqrt{2}) = 1.5, \quad \log_2 (5) \approx 2.322, \quad \log_2 (1.817) \approx 0.862 $$<p> </p>
$$ 1.5 + (2.5 + 0.5 \cdot r_P) \cdot 2.322 \geq 0.862 + 21.333 $$<p> </p>
$$ 1.5 + 5.805 + 1.161 \cdot r_P \geq 22.195 $$<p> </p>
$$ 7.305 + 1.161 \cdot r_P \geq 22.195 $$<p> </p>
$$ 1.161 \cdot r_P \geq 14.89 $$<p> </p>
$$ \lceil r_P \rceil \geq \Bigg\lceil \frac{14.89}{1.161} \Bigg\rceil \approx \lceil 12.825 \rceil = 13  
    $$<p>
Under the parameter settings we provided, after correctly interpreting the FW-GB attack cost formula, to achieve 128-bit security, the required partial rounds value is: </p>
$$r_{P}=13$$</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://sidereushu.github.io/">Sidereus Hu</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
