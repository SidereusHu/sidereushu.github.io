<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Poseidon Hash Algebraic Attack Analysis (Analyst&#39;s Perspective) | Sidereus Hu</title>
<meta name="keywords" content="">
<meta name="description" content="
In recent years, &ldquo;ZK-friendly&rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.">
<meta name="author" content="Sidereus Hu">
<link rel="canonical" href="https://sidereushu.github.io/posts/poseidon-hash-algebraic-attack-analysis-analysts-perspective/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css" integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sidereushu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sidereushu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sidereushu.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sidereushu.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://sidereushu.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://sidereushu.github.io/posts/poseidon-hash-algebraic-attack-analysis-analysts-perspective/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)'], ['$', '$']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
 


<meta property="og:url" content="https://sidereushu.github.io/posts/poseidon-hash-algebraic-attack-analysis-analysts-perspective/">
  <meta property="og:site_name" content="Sidereus Hu">
  <meta property="og:title" content="Poseidon Hash Algebraic Attack Analysis (Analyst&#39;s Perspective)">
  <meta property="og:description" content="
In recent years, “ZK-friendly” hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-18T16:57:25+08:00">
    <meta property="article:modified_time" content="2025-08-18T16:57:25+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Poseidon Hash Algebraic Attack Analysis (Analyst&#39;s Perspective)">
<meta name="twitter:description" content="
In recent years, &ldquo;ZK-friendly&rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sidereushu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Poseidon Hash Algebraic Attack Analysis (Analyst's Perspective)",
      "item": "https://sidereushu.github.io/posts/poseidon-hash-algebraic-attack-analysis-analysts-perspective/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Poseidon Hash Algebraic Attack Analysis (Analyst's Perspective)",
  "name": "Poseidon Hash Algebraic Attack Analysis (Analyst\u0027s Perspective)",
  "description": "\nIn recent years, \u0026ldquo;ZK-friendly\u0026rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.\n",
  "keywords": [
    
  ],
  "articleBody": "\nIn recent years, “ZK-friendly” hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.\nThis article approaches from an analyst’s perspective, based on a recent paper [GKR25], presents some factual conclusions from that work, and provides supplementary analysis for certain conclusions.\nRelated Work Core Method Effectiveness Analysis for Poseidon [FP20] Closed-form degree expressions Helpful for modeling Gröbner basis attacks [BBLP22] Skipping (multiple) full rounds Reduced actual nonlinear depth [ABM24] Round-level Gröbner basis modeling Shows underestimated vulnerabilities at κ = 1024 [BBL+24] FreeLunch Gröbner basis attack Ineffective due to low S-box degree [KLR24] “Six Worlds” analysis framework Not yet applied to Poseidon, has potential research value [GKR25] Forward Gröbner basis attack utilizing subspace trajectories Original analysis shows overestimation or underestimation of required security rounds [BBB+25] Iterated Resultants Reducible to simple univariate cases [GKR25] is the latest work proposed by the Poseidon designers. This work presents a series of analytical data for Gröbner basis attacks on Poseidon2 in Sponge mode in Table 5, specifically based on a two-step analysis of GB steps (Macaulay bound) and FGLM steps (conjectured dI). The authors then derive the minimum partial rounds value $r_P$ that can be set in Table 3 based on this data.\nThe authors provide a series of analytical data for Poseidon2 in both Sponge mode and Compress mode (Table 5 and Table 6 respectively), but do not provide partial rounds settings similar to Table 3. Based on Table 6 data, combined with the Gröbner basis attack complexity formula $(d_{MAC})^{\\omega}$, and setting $\\omega$ to 2 as in Table 3, we perform the following calculation:\nTo achieve 128-bit security, we need:\n$$(d_{MAC})^2 \\geq 2^{128}$$Taking the square root of both sides, we get the requirement for the Macaulay Bound $d_{MAC}$:\n$$d_{MAC} \\geq 2^{64}$$Taking the logarithm, we get the security threshold we need:\n$$\\log_2(d_{MAC}) \\geq 64$$As long as $\\log_2(d_{MAC})$ under a parameter configuration is greater than or equal to 64, we can consider it secure under this attack.\nLet’s put this into practice and verify this result.\nVerification of Poseidon Authors’ result Now, we select a set of parameters from the analytical data table (Table 5) provided by the authors, calculate the required minimum $r_{P}$ value using the “security threshold” method above, and verify whether this value matches the corresponding entry in Table 3. We select the second row of data from Table 5 as our example:\nState width: $t=4$ Digest length: $d=1$ Capacity: $c=1$ S-box: $α=3$ Security objective:\nThe security level we need to achieve is 128 bits. The attack complexity formula is $C_{GB}​≈(d_{MAC}​)^2$. Therefore, our security threshold is $\\log_{2}​(d_{MAC}​)≥64$. Calculation process:\nWhen $r_P = 1$: $\\log_2(d_{MAC}) = 17$ (\u003c 64, insecure) When $r_P = 2$: $\\log_2(d_{MAC}) = 35$ (\u003c 64, insecure) When $r_P = 3$: $\\log_2(d_{MAC}) = 41$ (\u003c 64, insecure) When $r_P = 4$: $\\log_2(d_{MAC}) = 59$ (\u003c 64, insecure) When $r_P = 5$: $\\log_2(d_{MAC}) = 113$ (\u003e 64, secure) Conclusion: For the parameter set $t=4$, $d=1$, $c=1$, $α=3$, the minimum number of internal rounds $r_P$ required to resist the subspace attack described in the paper and achieve 128-bit security is 5. This calculated result matches the conclusion in Table 3.\nParameter Analysis for Compress Mode After verifying the calculation from Table 5, we can use the “security threshold” method as an assessment tool to evaluate the security of any set of analytical data. Below, we conduct security evaluations for two parameter sets in Compress mode based on the analytical data in Table 6.\nFirst Parameter Set: $t=2$, $d=1$, $c=0$, $α=5$ Setting security threshold:\nThe security level we need to achieve is 128 bits. The attack complexity formula is $C_{GB}​≈(d_{MAC}​)^2$. Therefore, our security threshold is $\\log_{2}​(d_{MAC}​)≥64$. Calculation process:\nAfter selecting the corresponding data from Table 6, we perform the following calculations:\nWhen $r_P = 1$: $\\log_2(d_{MAC}) = 13$ (\u003c 64, insecure) When $r_P = 2$: $\\log_2(d_{MAC}) = 19$ (\u003c 64, insecure) When $r_P = 3$: $\\log_2(d_{MAC}) = 25$ (\u003c 64, insecure) When $r_P = 4$: $\\log_2(d_{MAC}) = 43$ (\u003c 64, insecure) When $r_P = 5$: $\\log_2(d_{MAC}) = 61$ (\u003c 64, insecure) When $r_P = 6$: $\\log_2(d_{MAC}) = 79$ (\u003e 64, secure) Conclusion: For the parameter set $t=2$, $d=1$, $c=0$, $α=5$, 6 partial rounds are needed to elevate the complexity of the strongest Gröbner basis subspace optimization attack above the 128-bit security level.\nSecond Parameter Set: $t=3$, $d=1$, $c=0$, $α=5$ Setting security threshold:\nThe security level we need to achieve is 128 bits. The attack complexity formula is $C_{GB}​≈(d_{MAC}​)^2$. Therefore, our security threshold is $\\log_{2}​(d_{MAC}​)≥64$. Calculation process:\nAfter selecting the corresponding data from Table 6, we perform the following calculations:\nWhen $r_P = 1$: $\\log_2(d_{MAC}) = 9$ (\u003c 64, insecure) When $r_P = 2$: $\\log_2(d_{MAC}) = 15$ (\u003c 64, insecure) When $r_P = 3$: $\\log_2(d_{MAC}) = 27$ (\u003c 64, insecure) When $r_P = 4$: $\\log_2(d_{MAC}) = 59$ (\u003c 64, insecure) When $r_P = 5$: $\\log_2(d_{MAC}) = 87$ (\u003e 64, secure) Conclusion: For the parameter set $t=3$, $d=1$, $c=0$, $α=5$, 5 partial rounds are needed to elevate the complexity of the strongest Gröbner basis subspace optimization attack above the 128-bit security level.\n",
  "wordCount" : "924",
  "inLanguage": "zh",
  "datePublished": "2025-08-18T16:57:25+08:00",
  "dateModified": "2025-08-18T16:57:25+08:00",
  "author":{
    "@type": "Person",
    "name": "Sidereus Hu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sidereushu.github.io/posts/poseidon-hash-algebraic-attack-analysis-analysts-perspective/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sidereus Hu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sidereushu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sidereushu.github.io/" accesskey="h" title="Sidereus Hu (Alt + H)">Sidereus Hu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sidereushu.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://sidereushu.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Poseidon Hash Algebraic Attack Analysis (Analyst&#39;s Perspective)
    </h1>
    <div class="post-meta"><span title='2025-08-18 16:57:25 +0800 CST'>2025-08-18</span>&nbsp;·&nbsp;Sidereus Hu

</div>
  </header> 
  <div class="post-content"><br>
<p>In recent years, &ldquo;ZK-friendly&rdquo; hash functions designed for zero-knowledge proof (ZK) scenarios have gained widespread attention. They are typically based on carefully constructed algebraic structures to exhibit lower constraint counts in arithmetic circuits, thereby achieving higher efficiency in proof systems. However, it is precisely this algebraic friendliness that exposes them to potential attack surfaces under certain analytical models. Particularly in recent years, algebraic analysis methods—such as Gröbner basis attacks and polynomial degree reduction techniques utilizing subspace trajectories—have seen significant research interest in the cryptanalysis field and have gradually become one of the core tools for evaluating the security of such hash functions.</p>
<p>This article approaches from an analyst&rsquo;s perspective, based on a recent paper [GKR25], presents some factual conclusions from that work, and provides supplementary analysis for certain conclusions.</p>
<table>
  <thead>
      <tr>
          <th>Related Work</th>
          <th>Core Method</th>
          <th>Effectiveness Analysis for Poseidon</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>[FP20]</strong></td>
          <td>Closed-form degree expressions</td>
          <td>Helpful for modeling Gröbner basis attacks</td>
      </tr>
      <tr>
          <td><strong>[BBLP22]</strong></td>
          <td>Skipping (multiple) full rounds</td>
          <td>Reduced actual nonlinear depth</td>
      </tr>
      <tr>
          <td><strong>[ABM24]</strong></td>
          <td>Round-level Gröbner basis modeling</td>
          <td>Shows underestimated vulnerabilities at κ = 1024</td>
      </tr>
      <tr>
          <td><strong>[BBL+24]</strong></td>
          <td>FreeLunch Gröbner basis attack</td>
          <td>Ineffective due to low S-box degree</td>
      </tr>
      <tr>
          <td><strong>[KLR24]</strong></td>
          <td>&ldquo;Six Worlds&rdquo; analysis framework</td>
          <td>Not yet applied to Poseidon, has potential research value</td>
      </tr>
      <tr>
          <td><strong>[GKR25]</strong></td>
          <td>Forward Gröbner basis attack utilizing subspace trajectories</td>
          <td>Original analysis shows overestimation or underestimation of required security rounds</td>
      </tr>
      <tr>
          <td><strong>[BBB+25]</strong></td>
          <td>Iterated Resultants</td>
          <td>Reducible to simple univariate cases</td>
      </tr>
  </tbody>
</table>
<hr>
<br>
<p>[GKR25] is the latest work proposed by the Poseidon designers. This work presents a series of analytical data for Gröbner basis attacks on Poseidon2 in Sponge mode in Table 5, specifically based on a two-step analysis of GB steps (Macaulay bound) and FGLM steps (<code>conjectured dI</code>). The authors then derive the minimum partial rounds value $r_P$ that can be set in Table 3 based on this data.</p>
<p><img loading="lazy" src="/images/GKR25_Table3.png"></p>
<p><img loading="lazy" src="/images/GKR25_Table5.png"></p>
<p>The authors provide a series of analytical data for Poseidon2 in both Sponge mode and Compress mode (Table 5 and Table 6 respectively), but do not provide partial rounds settings similar to Table 3. Based on Table 6 data, combined with the Gröbner basis attack complexity formula $(d_{MAC})^{\omega}$, and setting $\omega$ to 2 as in Table 3, we perform the following calculation:</p>
<p>To achieve 128-bit security, we need:</p>
$$(d_{MAC})^2 \geq 2^{128}$$<p>Taking the square root of both sides, we get the requirement for the Macaulay Bound $d_{MAC}$:</p>
$$d_{MAC} \geq 2^{64}$$<p>Taking the logarithm, we get the security threshold we need:</p>
$$\log_2(d_{MAC}) \geq 64$$<p>As long as $\log_2(d_{MAC})$ under a parameter configuration is greater than or equal to 64, we can consider it secure under this attack.</p>
<p>Let&rsquo;s put this into practice and verify this result.</p>
<hr>
<h2 id="verification-of-poseidon-authors-result">Verification of Poseidon Authors&rsquo; result<a hidden class="anchor" aria-hidden="true" href="#verification-of-poseidon-authors-result">#</a></h2>
<p>Now, we select a set of parameters from the analytical data table (Table 5) provided by the authors, calculate the required minimum $r_{P}$ value using the &ldquo;security threshold&rdquo; method above, and verify whether this value matches the corresponding entry in Table 3. We select the second row of data from Table 5 as our example:</p>
<ul>
<li>State width: $t=4$</li>
<li>Digest length: $d=1$</li>
<li>Capacity: $c=1$</li>
<li>S-box: $α=3$</li>
</ul>
<p><strong>Security objective:</strong></p>
<ul>
<li>The security level we need to achieve is 128 bits.</li>
<li>The attack complexity formula is $C_{GB}​≈(d_{MAC}​)^2$.</li>
<li>Therefore, our security threshold is $\log_{2}​(d_{MAC}​)≥64$.</li>
</ul>
<p><strong>Calculation process:</strong></p>
<ul>
<li>When $r_P = 1$: $\log_2(d_{MAC}) = 17$ (&lt; 64, insecure)</li>
<li>When $r_P = 2$: $\log_2(d_{MAC}) = 35$ (&lt; 64, insecure)</li>
<li>When $r_P = 3$: $\log_2(d_{MAC}) = 41$ (&lt; 64, insecure)</li>
<li>When $r_P = 4$: $\log_2(d_{MAC}) = 59$ (&lt; 64, insecure)</li>
<li>When $r_P = 5$: $\log_2(d_{MAC}) = 113$ (&gt; 64, <strong>secure</strong>)</li>
</ul>
<p><strong>Conclusion:</strong> For the parameter set $t=4$, $d=1$, $c=1$, $α=3$, the minimum number of internal rounds $r_P$ required to resist the subspace attack described in the paper and achieve 128-bit security is <strong>5</strong>. This calculated result matches the conclusion in Table 3.</p>
<hr>
<br>
<h2 id="parameter-analysis-for-compress-mode">Parameter Analysis for Compress Mode<a hidden class="anchor" aria-hidden="true" href="#parameter-analysis-for-compress-mode">#</a></h2>
<p>After verifying the calculation from Table 5, we can use the &ldquo;security threshold&rdquo; method as an assessment tool to evaluate the security of any set of analytical data. Below, we conduct security evaluations for two parameter sets in Compress mode based on the analytical data in Table 6.</p>
<p><img loading="lazy" src="/images/GKR25_Table6.png"></p>
<br>
<h3 id="first-parameter-set---"><strong>First Parameter Set</strong>: $t=2$, $d=1$, $c=0$, $α=5$<a hidden class="anchor" aria-hidden="true" href="#first-parameter-set---">#</a></h3>
<p><strong>Setting security threshold:</strong></p>
<ul>
<li>The security level we need to achieve is 128 bits.</li>
<li>The attack complexity formula is $C_{GB}​≈(d_{MAC}​)^2$.</li>
<li>Therefore, our security threshold is $\log_{2}​(d_{MAC}​)≥64$.</li>
</ul>
<p><strong>Calculation process:</strong></p>
<p>After selecting the corresponding data from Table 6, we perform the following calculations:</p>
<ul>
<li>When $r_P = 1$: $\log_2(d_{MAC}) = 13$ (&lt; 64, insecure)</li>
<li>When $r_P = 2$: $\log_2(d_{MAC}) = 19$ (&lt; 64, insecure)</li>
<li>When $r_P = 3$: $\log_2(d_{MAC}) = 25$ (&lt; 64, insecure)</li>
<li>When $r_P = 4$: $\log_2(d_{MAC}) = 43$ (&lt; 64, insecure)</li>
<li>When $r_P = 5$: $\log_2(d_{MAC}) = 61$ (&lt; 64, insecure)</li>
<li>When $r_P = 6$: $\log_2(d_{MAC}) = 79$ (&gt; 64, <strong>secure</strong>)</li>
</ul>
<p><strong>Conclusion</strong>: For the parameter set $t=2$, $d=1$, $c=0$, $α=5$, 6 partial rounds are needed to elevate the complexity of the strongest Gröbner basis subspace optimization attack above the 128-bit security level.</p>
<br>
<h3 id="second-parameter-set---"><strong>Second Parameter Set</strong>: $t=3$, $d=1$, $c=0$, $α=5$<a hidden class="anchor" aria-hidden="true" href="#second-parameter-set---">#</a></h3>
<p><strong>Setting security threshold:</strong></p>
<ul>
<li>The security level we need to achieve is 128 bits.</li>
<li>The attack complexity formula is $C_{GB}​≈(d_{MAC}​)^2$.</li>
<li>Therefore, our security threshold is $\log_{2}​(d_{MAC}​)≥64$.</li>
</ul>
<p><strong>Calculation process:</strong></p>
<p>After selecting the corresponding data from Table 6, we perform the following calculations:</p>
<ul>
<li>When $r_P = 1$: $\log_2(d_{MAC}) = 9$ (&lt; 64, insecure)</li>
<li>When $r_P = 2$: $\log_2(d_{MAC}) = 15$ (&lt; 64, insecure)</li>
<li>When $r_P = 3$: $\log_2(d_{MAC}) = 27$ (&lt; 64, insecure)</li>
<li>When $r_P = 4$: $\log_2(d_{MAC}) = 59$ (&lt; 64, insecure)</li>
<li>When $r_P = 5$: $\log_2(d_{MAC}) = 87$ (&gt; 64, <strong>secure</strong>)</li>
</ul>
<p><strong>Conclusion</strong>: For the parameter set $t=3$, $d=1$, $c=0$, $α=5$, 5 partial rounds are needed to elevate the complexity of the strongest Gröbner basis subspace optimization attack above the 128-bit security level.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://sidereushu.github.io/">Sidereus Hu</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
